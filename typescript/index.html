<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8">

        <title>TypeScript クイックガイド - phyzkit.net</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="TypeScript Quick Guide">
        <meta name="author" content="Kon">
        <meta name="keywords" content="TypeScript,チュートリアル,入門">

        <!-- Twitter Cards -->
        <meta name="twitter:card"         content="summary">
        <meta name="twitter:site"         content="@KDKTN">
        <meta name="twitter:url"          content="http://phyzkit.net/typescript/">
        <meta name="twitter:title"        content="TypeScript クイックガイド - phyzkit.net">
        <meta name="twitter:description"  content="現在 JavaScript を使用している開発者が、より大規模な Web アプリケーションの開発にも適した新しい言語 TypeScript に素早く移行できるように書かれたチュートリアルです。">
        <meta name="twitter:image"        content="http://phyzkit.net/typescript/logo_small.png">

        <!-- bootstrap -->
        <link href="../assets/bootstrap/css/bootstrap.css" rel="stylesheet">
        <link href="../assets/bootstrap/css/bootstrap-responsive.css" rel="stylesheet">

        <!-- Google Code Prettify -->
        <link href="../assets/google-code-prettify/prettify.css" rel="stylesheet">
        <script type="text/javascript" src="../assets/google-code-prettify/prettify.js"></script>
        <link href="style.css" rel="stylesheet">

        <script type="text/javascript" src="../assets/jquery-2.0.0.js"></script>        
        <script type="text/javascript" src="http://phyzkit.net/common.js"></script>

        <!-- Google Analytics -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-28131600-1']);
          _gaq.push(['_trackPageview']);

          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
    </head>

    <body data-spy="scroll" data-target=".bs-docs-sidebar">

        <!-- Navbar -->
        <div class="navbar navbar-inverse navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="brand" href="./index.html">phyzkit.net</a>
                    <div class="nav-collapse collapse">
                        <ul class="nav">
                            <li class=""><a href="../index.html">Home</a></li>
                        </ul>
                        <ul class="nav">
                            <li class=""><a href="#">Page Top</a></li>
                        </ul>
                        <ul class="nav">
                            <li class=""><a href="http://www.typescriptlang.org/" target="_blank">typescriptlang.org</a></li>
                        </ul>
                        <ul class="nav">
                            <li class=""><a href="TypeScript%20Language%20Specification.pdf" target="_blank">Language Specification</a></li>
                        </ul>
                        <ul class="nav">
                            <li class=""><a href="http://www.typescriptlang.org/Playground/" target="_blank">Playground</a></li>
                        </ul>
                        <ul class="nav">
                            <li class=""><a href="http://typescript.codeplex.com/" target="_blank">codeplex</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- subhead -->
        <header class="jumbotron subhead" id="overview">
            <div class="container">
                <h1>TypeScript Quick Guide</h1>
                <p class="lead">Starts from JavaScript, Ends with JavaScript.
            </div>
        </header>

        <!-- Content -->
        <div class="container">
            <div class="row">

                <!-- Side Menu -->
                <div class="span3 bs-docs-sidebar">      
                    <div class="menu"></div>

                    <!-- Twitter #typescript timeline -->
                    <p class="twitter-widgets" style="margin-top:4em; margin-right:10px;">
                        <a class="twitter-timeline" href="https://twitter.com/search?q=TypeScript" data-widget-id="299388741716410368">TypeScript に関するツイート</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

                        <a class="twitter-timeline" href="https://twitter.com/search?q=%23typescript" data-widget-id="299260141176487936">#typescript に関するツイート</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                        
                        <a class="twitter-timeline" href="https://twitter.com/typescriptlang" data-widget-id="300258941433155584">@typescriptlang からのツイート</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                    </p>
                </div>
                
                <!-- Center column -->
                <div class="span9">
                    
                    <!-- Twitter button -->
                    <div style="margin:16px;">
                        <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="http://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                    </div>

                    <!-- Main content -->
                    <pre id="content" class="markdown">
# TypeScript クイックガイド

このテキストは [プログラミング言語 TypeScript](http://www.typescriptlang.org/) のチュートリアルです。
現在 JavaScript を利用して開発している開発者が、スムーズに TypeScript へと移行するために必要な情報を解説しています。

#### 前提条件

本稿を読み進めるためには、おおまかに以下の項目についての知識が必要です：

* JavaScript
* 静的型付け
* クラスベースオブジェクト指向

JavaScript に加えて Java や C#, C++ のような言語からひとつを使用したことがあれば、事前の知識としては十分です。ただし、JavaScript に関してはある程度高度な内容に関しても断りなく文中で言及されますので、JavaScript の入門書を読んだだけのような段階の読者には理解しにくい説明が含まれます。たとえば、`Object.defineProperty` や Strict モードのような JavaScript の比較的新しい機能、Canvas 要素のようなまだ W3C 勧告の段階にない仕様や jQuery のようなライブラリ、node.js のような実行環境についても説明に登場ことがありますが、これらについての説明は本テキストにありませんので、必要に応じてほかの資料を参照してください。
冗長になるのを避けるため、JavaScript と共通する内容やオブジェクト指向一般についての説明は意図的に省いていますが、その代わり TypeScript で新たに導入される言語仕様についてはなるべく網羅するようにしています。

言語仕様書は以下のどちらかを参照してください。

* [TypeScript　Language　Specification Version 0.9](http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf)

* [~~TypeScript　Language　Specification Version 0.8~~](http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf)

TypeScript 0.9 で大幅に言語仕様が変更されましたが、今後 TypeScript 0.8 で新しくコードを書く理由はまずありませんので基本的には 0.9 の仕様書を参照してください。本ページは 0.9 への対応に向けて改稿中ですが、一部に 0.8 以前の古い記述が残っていることにも注意して頂きたいと思います。本稿の正確性については一切無保証ですので、正確な言語仕様については仕様書を確認してください。また、本稿のすべての所見は筆者個人の主観によるものであり、Microsoft の見解とは一切関係ありません。

## 概要
      
（能書きが長いですので、TypeScript つかうぞーっていうモチベーションがすでにある方はこの章は読み飛ばしてくださって結構です。）

現在、ほぼすべての Web ブラウザには JavaScript が搭載され動的なページの構築に使われていますが、Web ページがより高度化、複雑化するにつれ [JavaScript の機能の限界](http://www.haskell.org/haskellwiki/The_JavaScript_Problem) が明らかになってきました。より大きく複雑なアプリケーションの開発に耐えられるように JavaScript をさらに発展させようとする試みは今も進められていますが、互換性の維持や各ソフトウェアベンダの利害関係の調整により遅々として進まず、JavaScript による貧弱なプログラミング環境での開発が強いられているこの状況が改善される見込みはありませんでした。そのような JavaScript の欠点を補うべく [多くの言語](https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS) が提案されてきたもののいずれも一長一短あり、未だに根本的な解決には至っていません。

JavaScript が抱える多数の問題とそれを取り巻く現状に対して、TypeScript は他のどの言語よりも現実的なアプローチでの解決手段を提供します。TypeScript もまたコンパイラによって JavaScript 出力することでその代替を目指すシステムのひとつですが、TypeScript には以下の様な長所があります。

#### 静的型付け

コンパイル時に型チェックされ、堅牢で変化に強く可読性の高いプログラムの記述が可能です。型注釈が省略された識別子は、型推論により自動的に型注釈が補完されるなど、記述性も確保しています。静的な型付けが導入されたことにより、さらにインテリセンスのようなコーディングサポート、クラス名や変数名の変更などの自動的なリファクタリング、ドキュメントの自動生成、クラス名からその定義へのジャンプなど、動的な型付けでは不可能だった多数の機能が実現可能になります。また、型として any を指定することで従来の JavaScript と同様の動的な型の式として扱うことも選択できます。

#### ほぼ同じ構造の JavaScript へと変換される

出力される JavaScript コードは元の TypeScript コードの構造をほぼそのまま保っており、出力されたコードから元のコードとの対応を把握するのは容易です。このため、出力後の JavaScript をデバッグするのが容易になっています。また、どうしても必要なら出力後の JavaScript を修正することも難しくありません。出力したコードのサイズが膨らむことも一切ありません。

#### 標準化されたコードを生成できる

JavaScript にはモジュールやクラスを始め多数の機能が欠けているため、しばしば JavaScript フレームワークは[独自](http://docs.sencha.com/ext-js/4-0/#!/api/Ext-method-define)の[機構](http://wise9.github.com/enchant.js/doc/core/ja/symbols/enchant.Class.html#.create)で[これらを](http://dojotoolkit.org/reference-guide/1.8/dojo/_base/declare.html#dojo-base-declare)を[実現](http://prototypejs.org/learn/class-inheritance.html)しようと[しがち](http://backbonejs.org/#Model-extend)です[が](http://yuilibrary.com/yui/docs/api/classes/YUI.html#method_extend) 統一されない規約は可読性を低下させ、学習コストの増大とフレームワークごとの微妙な差異がもたらす混乱を招き、安易な工夫は思わぬ落とし穴を生むことがあります。TypeScript の統一されたクラスやモジュールの機構を利用することによって、洗練された機構の恩恵を安全に享受することができます。

#### JavaScript からの高い移植性

構文は基本的に JavaScript のスーパーセットであり、既存の JavaScript ソースコードにわずかな修正を加えるだけで TypeScript へと移植できます。筆者はプログラミング道の悟りを開くべく 2 万行以上の JavaScript をラフに移植するという [苦行](https://github.com/borisyankov/DefinitelyTyped/blob/master/threejs/three-tests.ts) を積んだことがありますが、感覚としてはコンパイルを通すだけなら 100 行に 2～3 行程度の修正で済むという程度です。その修正というのも、宣言のない変数や、型の異なるオブジェクトの間での変数の使い回しのような、JavaScript としても明らかに問題がある部分の修正が主だったりします。"use strict" を使っているなどして丁寧に書かれている JavaScript の移植では、まったく修正が不要で、拡張子を変えるだけでコンパイルが通る場合すらあります。

#### JavaScript との高い相互運用性


静的に型チェックされるという点以外はあらゆる API は JavaScript そのままですし、データ型もまったく同じなので特別なデータ型の変換を施さなくてもそのまま相互にデータをやり取りできます。また、既存の JavaScript コードに対して定義ファイルを記述することで、最低限の作業で TypeScript から安全に JavaScript を呼び出すことができます。JQuery のような著名なライブラリに対してはすでに宣言ソースファイルが提供されており、JQuery のノウハウをそのまま生かしてすぐに開発を始めることができます。

#### 学習の容易さ

言語仕様の大半は JavaScript のスーパーセットなので、すでに JavaScript を知っていれば、あとはいくらかの差分を学ぶだけで TypeScript を習得できます。構文の多くは EcmaScript6 を先取りした仕様なので、すでにある程度 EcmaScript6 の動向を追っている人にとっては違和感のない構文ばかりだと思います。データ型は JavaScript とほぼ同じであり、HTML DOM などの使い方も JavaScript から使った時とほぼ同じですから迷うことはありません。

#### 導入の容易さ

Node.js が提供するパッケージシステムで容易にインストールできます。また、すでに TypeScript コンパイラはセルフホスティングされており、ブラウザ内で TypeScript をコンパイルするようなことも実現されているなど、とてもポータブルです。JavaScript で実行できることから、コンパイラは OS を問わず使用することができます。

#### 自由なライセンス

TypeScript コンパイラ (tsc) は Apache License で提供されています。また、仕様は[Open Web Foundation
Final Specification Agreement](http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0) で提供されています。

その一方で、欠点や解決できない問題としては次のようなものが挙げられます。

#### JavaScript の知識が必要

発表間もない言語なので書籍はもちろんチュートリアルテキストも少なく、ブラウザオブジェクトの使い方などについては JavaScript におけるノウハウをそのまま流用することになります。TypeScript で直接書かれたライブラリもほとんどありませんので、通常は JavaScript で書かれたものを使います。SourceMap によって TypeScript ソースコードを参照しながらのステップイン/ステップオーバーのデバッグも可能ですが、SourceMap でうまくいかない場合はデバッグも JavaScript のレベルで行わざるをえなくなります。よく言えば『JavaScript の知識を流用できる』といえますが、悪いくいえば『結局 JavaScript の知識は必要』ということです。

#### 最適化はされない

最適化を多数施す JSX や Haxe のようなシステムと異なり、現在のところ TypeScript コンパイラにはまったく最適化の機能がありません。従って、実行効率は従来の JavaScript より低下こそしませんが、まったく向上もしません。

#### いくつかの JavaScript の言語仕様上の欠陥を克服できない
TypeScript は JavaScript のスーパーセットとして設計されているため、言語仕様の設計上大きな制約が加わっています。そのため JavaScript に存在する言語仕様上の欠点をすべて解消することはできず、一部は引き続き TypeScript においても存在しています。

* **this** - JavaScript の `this` キーワードの参照は関数の呼び出しかたに左右されるため、コールバックで this が直感的に機能しないなどの問題がありましたが TypeScript でも同じ欠点があります。ただし、クラス関数(インスタンスメソッド)内でインスタンス自身を参照しやすくするために、部分的に `this` の意味は変更されています。
* **プリミティブ型** - int や char のようなプリミティブ型がない貧弱な型システムや標準ライブラリも JavaScript と同じです。
* **typeof** - `typeof` や `instanceof` は寸分の違いもなくまったくそのまま JavaScript へコンパイルされます。従って、`typeof null === 'object'` のような困った仕様も当然そのままです。
* **変数のスコープ** - 変数のスコープは JavaScript と同じで、変数宣言の巻き上げ(hoisting)も引き続き行われます。for 文などの制御文はスコープを作らないので、即時関数パターン(immediate function pattern)のような面倒なイディオムも引き続き必要になります。
* **const/readonly** - クラスのカプセル化やイミュータブル(不変)なオブジェクトがほとんど実現できないというのはかなり深刻です。クラスの public なプロパティは外からでも書き換え放題で、つまり public なクラス関数(つまりインスタンスメソッド)を外から実装を差し替えるようなことも可能であるなど、他のクラスベースオブジェクト指向言語では当たり前の安全性は TypeScript ではいまいち不足しています。readonly の導入に前向きでないのは、ECMAScript 6 の型システムと互換性がとれなくなるから、というのが理由のようです。
* **import** - Java の `import` や C# の `using` に相当する、モジュールのシンボルをまとめてインポートするような機能はありません。`import` を導入すると変数のスコープが大幅に変更されることになるため、TypeScript に導入される見込みは薄いと思います。
* **型の別名** - モジュール名の別名は定義できるものの、型の別名を直接定義することはできません。

#### 言語仕様が貧弱

プリプロセッサも実用上は便利なときがありますが、現在の TypeScript には存在しません。ヒアドキュメントあたりも矛盾なくすぐに導入できる機能なので、せっかく新しい言語を導入したのにもったいないところです。とはいえ、0.9 でジェネリクスや Overload on Constants などが導入されそうで、ようやく JSX/Haxe/Dart となんとか肩を並べられる位置にまで達したのではないかと思います。

#### コンパイラが不安定

筆者にとっての現在の TypeScript 最大の不安材料はコレです。登場した当初よりは少しは安定してきましたが、現時点 (0.8.3) でもコンパイラの完成度に対する不安は拭えません。現在はプレビューの段階なので不安定なのは当たり前で、今すぐ実際に使おうとしている筆者のようなユーザはいくらなんでも気が早すぎではあります。あくまでプレビュー版だということを考慮に入れて、割りきって使いましょう。コンパイラの安定性については間違いなく今後改善されていくので、辛抱強く待つのがよいと思います。

TypeScript 0.9 でプリミティブ型 bool の名前が boolean に変更される、ジェネリクスが導入されるといった大きな変更がありました。どんなソフトウェアに変更とバージョンアップはつきものですが、もちろん TypeScript コンパイラも例外ではありませんから、言語仕様の変更についてはある程度覚悟しておくことが必要です。

## コンパイラの使用

TypeScript をコンパイルするには、おおまかに次の３つの方法があります。

### Playground

ブラウザ上で TypeScript のコンパイルと実行を試すことができる[Playground](http://www.typescriptlang.org/Playground/)が公開されています。ちょっとしたコードを試すにはこれが一番お手軽でしょう。入力されたコードはリアルタイムでコンパイルされ、コンパイル後の JavaScript が即座に確認できます。ソースコードはトークンに応じて色分けされ、変数にカーソルを合わせるとその型が表示されたり、なんとインテリセンスも効いたりします。とても良くできているので、TypeScript に慣れるにはまずは Playground でいろいろ試してみるのがいいでしょう。ちなみに、本ページ最上部のメニューバーにある「Playground」をクリックすると Playground をすぐ開くことができます。

### tsc

Playground も楽しいですが、本格的なアプリケーションを書くにはちゃんとローカルで動くコンパイラが必要です。TypeScript のコンパイラは node.js に付属するパッケージマネージャ npm を利用して簡単にインストールすることができます。まずは[http://nodejs.org/](http://nodejs.org/)から node.js をインストールします。node.js がインストールできたら、メニューから node.js のシェルを起動して、

```bash
>npm install -g typescript
```

を入力するだけで、TypeScript のコンパイラ tsc がインストールされます。試しに HelloWorld を書いてみましょう。テキストエディタで次のようなコードを書いて保存します(これは playground のサンプルコードの一部です)。

```js
module Greeting{
    export class Hello{
        constructor(private text : string){
        }
        say() : void{
            console.log(this.text);
        }
    }
}

var hello : Greeting.Hello = new Greeting.Hello("Hello, World!");
hello.say();
```

ソースコードのあるディレクトリに移動して、次のようなコマンドでコンパイルします。

```bash
>tsc hello.ts
```

コンパイルできたら、.ts と同名で .js が生成されたのがわかると思います。中を確認してみると、次のようなファイルになっています。

```js
var Greeting;
(function (Greeting) {
    var Hello = (function () {
        function Hello(text) {
            this.text = text;
        }
        Hello.prototype.say = function () {
            console.log(this.text);
        };
        return Hello;
    })();
    Greeting.Hello = Hello;    
})(Greeting || (Greeting = {}));

var hello = new Greeting.Hello("Hello, World!");
hello.say();
```

.ts と比較すると、それぞれの要素がどのように変換されたのかわかると思います。これはただの JavaScript ですから、ブラウザで実行することももちろん可能です。tsc はブラウザで実行するための HTML まで補完するシステムではありませんから、自分で適当に書きましょう。

```html
&lt;script type="text/javascript" src="hello.js"&gt;&lt;/script&gt;
```

これを HTML として保存し、ブラウザで読みこめば実行です。ブラウザのコンソールで次のような出力が得られるでしょう。

```bash
Hello, World!
```

まずはブラウザで実行してみましたが、tsc は node.js の環境で動作するツールでもあり、コンパイルと同時に node.js 環境で実行することも可能です。コンパイルと同時に node.js で実行するには、-e もしくは --exec オプションを付加します。

```bash
>tsc -e hello.ts
Hello, World!
```

また、オプションとして @filename を渡すと、filename で指定したテキストファイルをコンパイルオプションとして読み込んでコンパイルすることができます。多数のファイルを同時にコンパイルするときにはこちらのほうが便利でしょう。

さらに、便利なオプションとして --watch オプションがあります。このオプションをつけると、現在のディレクトリ下の TypeScript ソースファイルを監視して、ソースコードが更新されると自動的にコンパイルしてくれます。JavaScript で開発していたときのように、ソースコードを編集して保存したらブラウザを更新すればすぐ反映されるのでちょっと便利です。

そのほかのコンパイルオプションについては、

```bash
>tsc -h
```

を実行して閲覧できるヘルプを参照してください。

### Visual Studio プラグイン

Visual Studio で TypeScript の開発が可能になるプラグインも提供されています。統合開発環境のサポートが欲しい人はこれを使うのがいいでしょう。変数名にカーソルを合わせると型や jsdoc スタイルのインラインドキュメントが表示されたり、Internet Exploler と連携してデバッグを行ったり、名前変更のような基本的なリファクタリング機能もあります。

* [TypeScript for Visual Studio 2012](http://www.microsoft.com/en-us/download/details.aspx?id=34790)
* [~~TypeScript 0.8.3~~](https://typescript.codeplex.com/releases/view/98308)
* [~~TypeScript 0.9.0 Alpha~~](https://typescript.codeplex.com/releases/view/105503)

0.8 までと 0.9 以降ではかなり言語仕様に違いがありますが、基本的にはなるべく新しいものを使うのがよいと思います。

### WebStorm

JavaScript IDE として有名な [WebStorm](http://www.jetbrains.com/webstorm/) はすでに TypeScript に対応しており、WebStorm 上で TypeScript ソースコードの編集が行えるようです。筆者は WebStorm を使っていないのでここでは解説できませんが、WebStorm をすでに使っている方や Visual Studio 以外の IDE を探しているかたは WebStorm の利用を検討してみるのもよいのではないかと思います。

* 参考: [TypeScript Support](http://www.jetbrains.com/webstorm/webhelp/typescript-support.html)

### git リポジトリの clone

なるべく新しいコンパイラを使いたければ、[Codeplex](https://typescript.codeplex.com/) 上の TypeScript コンパイラのリポジトリを clone して tsc を使うのがいいでしょう。git がインストールされていれば、

```bash
git clone https://git01.codeplex.com/typescript
```

で clone できます(なぜか clone できないという場合もあるらしい？)。ビルトには [jake](https://npmjs.org/package/jake) が必要ですが、コンパイル済みの tsc も bin ディレクトリに入っているので、コンパイラを改造するのでなければこれをそのまま使ってもいいと思います。

## 言語仕様

### 単純な型
#### プリミティブ型

TypeScript のデータ型は概ね JavaScript のものと同じです。プリミティブ型として、**Number**、**Boolean**、**String**、**Null**、**Undefined** が使用可能です(3.2 Primitive Types)。
これらのデータ型は、JavaScript のデータ型とそのまま対応しており、各プリミティブ型のリテラルもまったく同じように書きます。また、ソースコード中ではこれらの型をそれぞれ **`number`**, **`boolean`**, **`string`** というキーワードで書きます。
また、Null, Undefined については、これらの値は JavaScript と同様にそれぞれ **`null`**, **`undefined`** というリテラルで参照できます。`null` や `undefined` を型に持つ変数を定義することはできません。

**TypeScript 0.8 以前では Boolean 型の型リテラルは `bool` でしたが、TypeScript 0.9 以降では `boolean` に変更されました。0.9 以降を使う場合は、常に `boolean` と書くようにしたほうがいいでしょう。本稿でもすでに `boolean` を使うように変更してありますが、0.8 でコンパイルする必要がある場合は、`bool` と書かなければならないことに注意してください。**

いきなり少々わかりづらいのですが、プリミティブ型 `number`, `boolean`, `string` と別にインターフェイスとして定義された `Number`, `Boolean`, `String` という型が存在しています。`number` は `Number` へと、`boolean` は `Boolean` へと、`string` は `String` へと暗黙に変換されるので、`number` と `Number`、 `boolean` と `Boolean`、`string` と `String` はそれぞれまったく同じプロパティを持っているかのように見えます。さらにわかりづらいことに `Nnumber`, `Boolean`, `String` という関数（要するにコンストラクタ）も存在しています。

このあたりの複雑さは JavaScript の仕様そのものなのでやむをえません。プリミティブ型に関してこのあたりは一見わかりづらいですが、**型注釈で型名を書くときには、ほとんどの場合は `Number`, `Boolean`, `String` ではなく `number`, `boolean`, `string` のほうを書いておけばよい**とだけ覚えておけばだいたい問題ないと思います。あとはすべて JavaScript で書くときと同じです。

#### any

JavaScript の変数の型に対応するものとして、**`any`** が存在します。any である式はどんなプロパティにアクセスしてもコンパイルエラーになりませんし、
`any` な変数に何を代入してもコンパイルエラーにならないので、JavaScript の通常の変数と同じように扱うことができます。ただし `any` を使うと TypeScript の静的な型チェックのメリットが失われてしますので、濫用すべきではないでしょう。`any` は既存の JavaScript コードを移植するようなときや、JSON 形式のデータを扱うような場合に便利なことがあります。また、後に説明するように `any` にキャストするとどんな式でもあらゆる型チェックを回避できるので、どうしてもうまく書けない時の回避策としても重要です。

#### void

**`void`** は関数の返り値がないことを示す型です。`void` の変数を定義するようなことはできません。

### 変数の型注釈

TypeScript の型注釈は、ECMAScript4 や ActionScript における型注釈と似たような構文になっています。
変数の型を示すには、その変数を宣言するときに変数のすぐ後ろにコロンと型を書きます。

```js
var name: string = "Jorn";
```

プリミティブ型の節で述べたように、プリミティブ型で型注釈を加えるときには、ほとんどの場合は `number`, `boolean`, `string` を使うことになるかと思います。

型注釈を省略した場合、**型推論**によって変数の型が決定されます。したがって、先程のコードで型注釈を省略しても、変数 `name` には文字列が代入されていることから `name` の型は `string` であると推論され、`name: string` と型注釈がつけられたのと同じになります。

TypeScript はほぼ JavaScript のスーパーセットになっていますが、すべての JavaScript ソースコードが同じようにコンパイルが通るわけではありません（Wikipedia にあらゆる既存のソースコードが TypeScript としてコンパイルが通る、というような記述がありましたが、さすがにそこまでではないです）。以下のコードは JavaScript のソースコードとしては問題ありませんが、TypeScript では型推論によって `name` は `string` 、`age` は `number` と推論され、その結果 `name` に `age` を代入してもコンパイルエラーになります。

```js
var name = "john";
var age = 30;
name = age;　// Cannot convert 'number' to 'string'
```

普段から型を意識してコーディングしている人は、JavaScript でもこんなことは滅多にしないとは思います。

型推論は便利ですが、万能ではありません。型推論がうまくいかない場合は、変数や関数の返り値の型が `any` と推論されてしまうことがあります。
```js
var hoge;
hoge = "ほげ";
var piyo: number = hoge;  // No Error...
```

上記のコードで、変数 hoge は次の行で `"ほげ"` が代入されているので `hoge: string` と推論されるかと思いきや、`hoge: any` となっています。このため、 `piyo: number` に代入しても何もエラーは出ません。TypeScript の型推論はまだそれほど強力ではありませんし、原理的に型推論と相性の悪い、関数のオーバーロードのような機能もあります。型注釈はコードの可読性を高めるためにも大変有効ですから、少々面倒でも可能な限り型注釈は与えておくのをお勧めします。

型注釈の型の部分には、number のような単純な型名やクラス名、インターフェイス名のほかに、
**型リテラル**(Type Literal)を書くことができます。型リテラルには関数型リテラル、コンストラクタ型リテラル、オブジェクト型リテラルといった種類がありますが、
これらについては各節で順次紹介していきます。


### 関数

#### 関数型リテラル

TypeScript は静的型付けなので、関数の型も明示的に書く方法があります。関数の型は次のように 丸括弧で囲んだ引数のあとに => と返り値の型を書き、これを**関数型リテラル**(Function Type Literals)といいます(3.5.5 Function Type Literals)。

```js
js(a: A, b: B, ...) => T 
```

この関数型リテラルは、型を書くところならどこにでも書くことができます。たとえば、HTMLElement の onclick は MouseEvent を引数にとるような関数でなければなりませんが、onclick は HTMLElement というインターフェイスで次のように定義されています。


```js
onclick: (ev: MouseEvent) => any;
```

もちろん、変数や引数を関数の型で型注釈を加えたり、後に紹介する型アサーション（ようするにキャスト）で使ったりすることももちろん可能です。

また、これらの関数の型をもつようなオブジェクトは JavaScript の　Function インターフェイスのオブジェクトでもあります。Function インターフェイスには apply や call のようなプロパティが定義されていますので、apply や call も JavaScript と同じように呼び出すことができます。

```js
var hoge : ()=>void = function(){
    ...
};

var piyo:Function = hoge;   // Function な変数に代入してもOK
hoge.apply(null);           // ()=>void な式に対して apply も呼べる
```


#### 省略可能な引数                

省略可能な引数には、引数名の直後に ? (クエスチョンマーク)を書きます。たとえば、String.indexOf の第２引数は省略可能なので、
indexOf は次のように定義されています。

```js
indexOf(searchString: string, position?: number): number;
```

また、省略可能な引数には省略した場合のデフォルト値を、　= を使って次のように与えることができます。


```js
indexOf(searchString: string, position: number = 0): number;
```

デフォルト値を指定しなかった場合は、JavaScript で引数が不足していた場合と同じように undefined になります。また、省略可能な引数のあとには通常の引数を書くことはできません。このあたりは他の言語と同じです。

**TypeScript 0.8 では `position?: number = 0` というように省略可能な引数であることを示す `?` とデフォルト値の指定の両方を書くことができましたが、0.9 以降はデフォルト値が指定されている場合は `?` をつけることができなくなりました。** デフォルト値が指定されている場合はそれは省略可能であることは明らかであり、コードに必要以上の冗長さが生じないようにするためです。

#### 可変長引数

可変長引数は、その引数の識別子の前に ... (ピリオド３つ)を書くことで表します。その場合、その変数は複数の値を受け取るわけですから、その型は配列型になります(Java では可変長引数でも [] をつけませんので、ここは Java あたりと微妙に異なります)。また、可変長引数はその関数の引数のうち、最後に位置しなければなりません。可変長引数については仕様書にもまだあまり詳しく書かれていませんが、コンパイラ本体のソースコードや JQuery などの外部ライブラリ用の定義ファイルなどでもすでにあちこちで使われているようです。たとえば、JQuery の append には文字列か HTMLElement および jQuery のいずれかをいくつでも渡せるので、次のように定義されています。


```js
append(...content: any[]): JQuery;
```

#### function 文と function 式における型注釈

変数やプロパティに型注釈をつける場合は、先ほど説明したように関数型リテラルを使えばよいですが、
function 文で関数を定義する場合にも型注釈をつけることができます。function 文への型注釈は、
仮引数にはそれぞれ変数と同じようにコロンと型を書き、返り値の型を括弧のあとに書きます。
例えば、string を受け取って number を返す parseNumber なら、次のようになります。

```js
function parseNumber(str: string) : number {
    ... 
}

```

function 式についても同様に型注釈を加えることができます。先ほどの parseNumber を function 式と変数を使って定義する場合は、次のように書けます。

```js
var parseNumber : (str : string) => number = function (str : string) : number{
    ... 
}

```

省略可能な引数や引数のデフォルト値、可変長引数の書き方も、関数型リテラルと同様です。


                
#### 関数のオーバーロード

TypeScript では関数のオーバーロードが可能です( 6.3 Function Overloads )。
といっても関数名のマングリングが行われるわけでもなく、関数本体はあくまで単一です。
同名の関数のシグニチャを引数の型を変えて複数定義することができ、コンパイル時には適合するシグニチャが検索されて型チェックが解決されます。
その関数の本体は、それぞれのシグニチャに対応するように、型が異なっている部分の引数の型を any や Object などのそれらの型を抽象できる型にします。
引数の型によって実装を切り替えるようなことはできませんが、表面的にはオーバーロードしているように見えます。オーバーロードはクラスのメンバ関数やコンストラクタでも可能です。

たいていの場合は関数本体では引数で渡されたオブジェクトの実際の型を判定する必要があると思いますが、JavaScript と同じように typeof や instanceof を使って調べればOKです。**typeof(null) が "object" だったりする悪習は脈々と受け継がれている**ので気をつけましょう。TypeScript は基本的に typeof や instanceof のような JavaScript 言語仕様の要素に対して意味の変更を加えることはありません(this だけ例外的に意味を変更しています)。たとえば、ベクトルか二つの数をとって新たなベクトルオブジェクトを返すような関数　createVector をオーバーロードで定義すると、つぎのようになります。

```js
function createVector(v:Vector2):Vector2;             // ベクトル一つを渡すときのシグニチャ    
function createVector(x:number, y:number):Vector2;    // ふたつの number を渡すときのシグニチャ
function createVector(a:any, b?:number):Vector2{      // 関数本体のシグニチャは createVector のシグニチャには含まれない。
    var v = new Vector2();                            
    if(a instanceof Vector2){                         // instanceof でどちらが呼ばれたのか判断
        v.x = a.x;
        v.y = a.y;
    }else{
        v.x = a;
        v.y = b;
    }
    return v;
}

var v:Vector2 = createVector(new Vector2(10, 20));  // Vector2 を渡すと (v:Vector2) => Vector2 が選択される
var u:Vector2 = createVector(10, 20);               // number ふたつだと (x:number, y:number) => Vector2 が選択される
var w:Vector2 = createVector("10", "20");           // ("10", "20") に適合するものはないので、コンパイルエラー
```            

本体の定義で、引数はどのシグニチャが選択されても対応できるような型にしておかなければなりません。
引数 a は Vector2 か number のどちらかなので、どちらにも対応できるよう a:any としておきます(どちらでも受け取れればいいので、a:Object とすることも可能です)。
引数 b は渡されない(undefined になる)か number を渡されるかなので、b?:number でいいでしょう。

このように function 文でオーバーロードされた関数を定義することもできますが、他にも『オブジェクト型リテラル』を使ってオーバーロードする方法があります。
オブジェクト型リテラルを使うとオーバーロードされた関数の型を示すようなこともできますが、オブジェクト型リテラルについて詳しくは後述します。

0.8 以前では、以下のように本体の定義よりあとにオーバーロードされたシグニチャを書くことができました。0.9 以降はこれはコンパイルエラーになるよう変更されました。

```js
// 0.8 以前でのみコンパイル可能
function createVector(a:any, b?:number):Vector2{
    ...
}
function createVector(v:Vector2):Vector2;    
function createVector(x:number, y:number):Vector2;
```


#### 定数によるオーバーロード

`document.createElement` は引数に渡した HTML タグ名から該当する HTMLElement オブジェクトを新しく作成する関数ですが、以下のように文字列リテラルを渡した場合でも型としては HTMLElement を返すので、TypeScript 0.8 以前ではいちいち型アサーションを書く必要が多くありました。例えば `createElement` に文字列リテラル `'p'` を渡したとすると、 `createElement` は常に `HTMLParagraphElement` オブジェクトを返すのは明らかです。しかし、ここで作成したオブジェクトを `p: HTMLParagraphElement` という変数に代入するには、
`&lt;HTMLParagraphElement&gt;` という型アサーションを書く必要がありました。

```js
var p: HTMLParagraphElement = &lt;HTMLParagraphElement&gt; document.createElement('p');
```

このような煩わしさを軽減するため、TypeScript 0.9 からは **Overloading on Constants**、すなわち引数の文字列定数に応じた関数のオーバーロードが可能になりました。0.9 では `document.createElement` は次のように定義されています(lib.d.ts を一部抜粋しています)。

```js
interface Document extends Node, HTMLDocument {
    createElement(tagName: string): HTMLElement;
    createElement(tagName: "a"): HTMLAnchorElement;
    createElement(tagName: "abbr"): HTMLElement;
    ...
    createElement(tagName: "p"): HTMLParagraphElement;
    ...
}
```

ここで　`createElement(tagName: "p"): HTMLParagraphElement` は、 `createElement` を呼び出すときに文字列リテラル `"p"` を渡すと、返り値の型は `HTMLParagraphElement` になることを定義しています。このようにコンパイラが引数に応じてその型を決定することができるので、先ほどの例でも型アサーションを省略して次のように書くことができます。

```js
var p: HTMLParagraphElement = document.createElement('p');
```

直接文字列リテラルを渡すのではなく変数や関数の返り値を渡す場合は、どのような値が渡されるかを静的に決定することはできませんから、 `createElement(tagName: string): HTMLElement` というこれまでの定義が選択されます。

```js
var tagName: string = 'p';

var p: HTMLParagraphElement = &lt;HTMLParagraphElement&gt; document.createElement(tagName); // 型アサーションが必要
```

他にも `addEventListener` や `getElementsByTagName` など多数の関数が Overloading on Constants を使用してオーバーロードされています。JavaScript ではこのようにひとつの関数に機能が集約されていることがよくあるので、とても JavaScript の特性に適した機能だと思います。

* 参考: [Announcing TypeScript 0.9](http://blogs.msdn.com/b/typescript/archive/2013/06/18/announcing-typescript-0-9.aspx) 

#### アロー関数式

アロー関数式 (Arrow Function Expressions) はいわゆる無名関数の構文で、JavaScript の function 式による構文に比べてシンプルに書けるようになっています。

```js
(a : A, b : B, ... ) => { ... }
```

これは次のように単に function 式として出力されます。

```js
function(a, b, ... ){ ... }
```


まず関数の引数をカンマで区切って並べ、それをかっこで囲んだのが引数部です。そのあとに => 、関数本体と続けます。
引数がひとつの場合はカッコを省略することができたり、関数本体がひとつの文の場合は中括弧と return を省略することができます。
以下の４つの式は、いずれも同じ関数リテラルを表しています (4.9.2 Arrow Function Expressions)。

```js
(x) => { return Math.sin(x); }
(x) => Math.sin(x)
x => { return Math.sin(x); }
x => Math.sin(x)

```

実はアロー関数式は function 式とはまったく同じではなく、後に説明するように アロー関数式と function 式とは this の扱いが異なりますから注意しましょう。



### 配列

配列の型を書くには、型のあとに [] を置きます。

```js
var seasons : string[] = ["spring", "summer", "fall", "winter"];
```            

将来的にはジェネリクスが導入され、`T[]` `Array&lt;T&gt;` の別名になるようです。
現在のところ、コンパイラに同梱された JavaScript の標準ライブラリの定義ファイル lib.d.ts の配列 interface Array の定義では、 _element という型が特別に要素の型として解釈されるようになっています。



### オブジェクト型リテラル

あるオブジェクトがどんなプロパティをもっているか、
関数として呼び出せるか、配列のようにインデックスで参照できるか、コンストラクタとして new できるかなどは、
**オブジェクト型リテラル** (Object Type Literal)を使用して表現できます。(3.5.3 Object Type Literals)。
オブジェクト型リテラルは型リテラルの一種で、以降に説明するいくつかのシグニチャのセットを { } でまとめたものです。これらのシグニチャをいくつでも自由に組み合わせることができ、その型のオブジェクトの性質を柔軟に記述することができます。このオブジェクト型リテラルは、変数の型注釈や関数の返り値の型など、型を書くところならどこにでも書くことができます。



#### プロパティシグニチャ

その型のオブジェクトが少なくとも持っているプロパティを定義するには、　

```js
プロパティ名: 型　
```

という形式の**プロパティシグニチャ**を使います。
例えば、少なくとも position:Vector2, paint:()=>void　という 2 つのプロパティをもつオブジェクトの型は、

```js
{ 
    position: Vector2; 
    paint: ()=>void;
}

```

と書きます。
また、このような型をもつオブジェクトに対しては、型で定義された position や paint というプロパティにのみアクセスでき、
そのような型の変数には　position:Vector2 や paint:()=>void を持つようなオブジェクトを代入できます。
次のコードでは少なくとも position:Vector2 と paint:()=>void をプロパティとして持つようなオブジェクトを代入できる object2d という変数を定義しています。 


```js
var object2d: { position: Vector2; paint: ()=>void; };

// object2d には position, paint を持つようなオブジェクトを代入できる
object2d = { 
    posiion : new Vector2(10, 20), 
    paint : ()=>{ console.log(this.position.x + "," + this.position.y); },
    size : 30     // 不必要なメンバがあっても代入はできる
};

// 型から object2d は position を持っていることが保証されるので、position にアクセスできる
console.log(object2d.position.x);

```     

また、先ほどのコードで object2d が参照しているオブジェクトは実行時に実際には size というプロパティも持っているはずですが、型は
    静的に解決されるのでこのプロパティにはアクセスできません。

```js
console.log(object2d.size); // コンパイルエラー！size というプロパティはない
```

#### 関数シグニチャ


関数であるようなプロパティを定義するためのシグニチャとして、`関数名(引数...): 返り値の型` という形式の**関数シグニチャ**というものもあります。
先ほど説明したプロパティシグニチャでも関数であるようなプロパティの型を示せますが、
関数シグニチャのほうが function 式やメンバ関数の構文に近いので、こちらを使ったほうが直感的というひともいるかもしれません。
先ほどのコードにおいて、 hello というプロパティの型は関数でしたが、これを次のように関数シグニチャで表すこともできます。


```js
var object2d : { 
    position: Vector2; 
    paint(): void;      // 関数シグニチャ。 paint: ()=>void と同じ
};
```        

また、同じ名前でシグニチャの異なる複数の関数シグニチャを定義することで、オーバーロードされた関数を表すことが可能です。
    プロパティシグニチャでは同じ名前の複数のプロパティを定義することはできないので、オーバーロードされた関数を定義する場合は次のように関数シグニチャを使うか、
    後述するコールシグニチャを使う必要があります。
    このようなオーバーロードは後に紹介するコンストラクトシグニチャでも可能で、オーバーロードされたコンストラクタも表現できます。


```js
var object2d: { 
    setPosition(x:number, y:number):void;   //　オーバーロード！
    setPosition(p:Vector2):void; 
}; 

object2d.setPosition(10, 20);               // number ふたつでもいいし、
object2d.setPosition(new Vector2(10, 20));  // ベクトルでも渡せる 

```

#### インデックスシグニチャ

**インデックスシグニチャ**(Index signiture)があれば、そのオブジェクトに対して `[]` を利用してアクセスできます。
インデックスシグニチャは `[]` の中にインデックスの型、コロンのあとに値の型を書きます。

```js
var v : { [index:number]:number; } = {};
v[0] = 10;
v[1] = 20;
console.log(v[0]);

```

ただし、現時点ではなぜか普通の `Array` と互換性がないなどの問題があるようです。

```js
var v: { [index:number]:number; } = []; // コンパイルエラー！
```

`[]` は `any[]` という型になるようで、`any[]` を `number[]` に代入するようなことは可能ですが、インデックスシグニチャとはうまく互換性がありません。とはいえ、これは安全なコードであるはずなので、`&lt;any&gt;` などを使ってやや強引に解決してしまって構わないと思います。

```js
var hoge : { [index:number]:number; } = &lt;any&gt; []; // 型チェックがゴミのようだ！
```

また、最初期のバージョンではインデックスの型に `any` が許容されていましたが、現在では `string` か `number` のみが認められています。


#### コールシグニチャ

**コールシグニチャ**(Call signitures)があれば、そのオブジェクトを関数のように呼び出せます。
コールシグニチャは括弧の中に引数列と、その後ろにコロンと返り値の型を書きます。
たとえば、文字列をひとつ引数にとって void を返す関数 paint があったとすると、その型注釈は次のように書けます。

```js
var paint: { (text:string):void; };    
paint("Hello!");    // コールシグニチャがあるので、関数として呼び出せる

```

この場合、関数型リテラルを使って次のように定義するのと同じです。

```js
var paint: (text:string)=>void;    
paint("Hello!"); 

```


このような単なる関数であれば関数型リテラルを使って定義してもいいのですが、JavaScript の関数はオブジェクトでもありプロパティを持つことができるので、
関数としても呼び出せるしプロパティも持っているというような型を示すには、オブジェクト型リテラルでコールシグニチャとプロパティシグニチャなどを組み合わせる必要があります。

```js
var paint: { (text:string): void; color: string; };
paint.color = "#00f";    // プロパティも持てるし    
paint("Hello!");         // 関数として呼び出せる

```

オブジェクト型リテラルに複数のコールシグニチャを含めれば、オーバーロードされた関数の型を示すこともできます。

```js
var paint: { 
    (text:string): void; 
    (num:number): void;
    (condition:boolean): void;
    color: string; 
};
paint.color = "utf8";      // プロパティも持てるし
paint("Hello!");           // string
paint(42);                 // number
paint(true);               // boolean でオーバーロードしてる！

```

また、先ほど関数シグニチャでオーバーロードされた関数を定義する例として挙げたコードも、次のようにコールシグニチャで表現することが可能です。
                
```js
var object2d:{ 
    setPosition: {
        (x:number, y:number):void;
        (p:Vector2):void;
    };
};

object2d.setPosition(10, 20);               // number ふたつでもいいし、
object2d.setPosition(new Vector2(10, 20));  // ベクトルでも渡せる 

```

#### コンストラクトシグニチャ

あるオブジェクトが new できるかどうかは、**コンストラクトシグニチャ**(Construct signitures)の有無によります。

オーバーロードされたコンストラクタを定義することも可能です。

```js
var Object2D : { 
    new (x:number, y:number): Object2D;
    new (x:Vector2): Object2D;
};

var objectA: Object2D = new Object2D(10, 20);   // number ふたつで new することもできるし、
var objectB: Object2D = new Object2D(v);        // ベクトルを渡して new もできる

```

ただ、普通は new できるようなオブジェクトはクラスを表している場合が大半なので、素直にクラスとして書くほうが読みやすいのではないかと思います。
コンストラクトシグニチャは既存の JavaScript コードの型の定義を書くときにが使われることが多いようです。
ちなみに、コンストラクトシグニチャではコンストラクタが返す値の型はどんな型にでもできたりします。

```js
var Object2D: {
    new (x:number, y:number): string;   // new Object2D で string が返る……？
};

var s:string = new Object2D(10, 20);    // コンパイルは問題ないけど、わけがわからないよ

```                

JavaScript では new Hoge() という式で Hoge でないオブジェクトを返したりできるので、このような機能もごく稀に必要になるようです。
    (でも上のサンプルはプリミティブ型である string を返しているので明らかにおかしいです)

    
#### 省略可能なプロパティ

また、プロパティシグニチャのプロパティ名の後や関数シグニチャの関数名のあとに **?** (クエスチョンマーク)
をつけると、そのプロパティはあってもなくても構わない省略可能なプロパティということになります。
省略可能なら定義する意味はないのでは？と思うかもしれませんが、そのプロパティが異なる型で定義されていたときに型エラーを検出できるというメリットがあります。




ある関数に省略可能な多数の引数を渡したいというときに、オブジェクトに格納して渡すことが JavaScript ではよくあります。
    たとえば、JQuery の ajax() にはオブジェクトにエラーハンドラやタイムアウトの秒数などの多数のオプションをオブジェクトに格納して渡すことができますが、
このオプションを格納するオブジェクトの型は JQueryAjaxSettings というインターフェイスで定義されています。
このインターフェイスのプロパティは全部省略可能になっており、ユーザが渡したいオプションだけ渡して使うことができます。


```js
interface JQueryAjaxSettings{
    ...
    dataType?: string;
    error?(jqXHR: JQueryXHR, textStatus: string, errorThrow: string): any;
    global?: boolean;
    success?(data: any, textStatus: string, jqXHR: JQueryXHR);
    timeout?: number;
    ...
}

interface JQueryStatic{
    ...
    ajax(url:string, settings;JQueryAjaxSettings):any;
    ...
}


JQuery.ajax("hogehoge.txt", { 
    success: (data)=> console.log(data),  
    dataType: 'text',
    timeout: '30秒'  // timeout は number でなければならないのでコンパイルエラー！
});

```

注意しておきたいのは、JQueryAjaxSettings のようなインターフェイスを用意して型エラーを検出できるとしても、**プロパティ名の入力ミスにはまったく無力だということです**。タイプミスしてもそのプロパティはもとからあってもなくてもよいものなのでプロパティが足りないことにはならないし、誤ったスペルのプロパティがあっても Sutructual Subtyping のおかげで無視されてしまうからです。

```js
JQuery.ajax("hogehoge.txt", { 
    sucess: (data)=> console.log(data)  // ajax に成功しても何も起きない。タイプミスだけどコンパイルエラーは出ない
});

```

### インターフェイス

**インターフェイス** (interface) はオブジェクト型リテラルに別名を定義します。
Java や C# にある「インターフェイス」と目的は似ていますが、TypeScript のインターフェイスは
どんなオブジェクト型リテラルについても別名をつけられるので、コールシグニチャが含まれるようなオブジェクト型リテラルをインターフェイスとして定義すると、
関数の型にも別名を付けられることになります。インターフェイスの定義は、キーワード interface のあとにインターフェイス名、そのあとに
オブジェクト型リテラルを書きます。


```js
// インターフェイスの定義
interface Person{
    name : string;
    birthday : Date;
    hello: ()=>void;
}

// Person な変数には name, birthday, hello が揃っていれば入れられる
var person : Person = {
    name: "John",
    birthday: new Date("01/01/70 00:00:00"),
    hello: function(){ console.log("Hello, my name is " + this.name); }
}; 

person.hello();

```

次は関数のシグニチャに別名を与えてみた例です。

```js
// Id であるオブジェクトは、(n:string):string か (n:number):number で呼び出せる
interface Id{
    (n:string):string; 
    (n:number):number;
}

// id を Id として定義する 
var id : Id = function(arg){ 
    return arg;
}

var n : number = id(100);       // number を渡すと id(n:number):number が選択される
var s : string = id("100");     // string を渡すと id(n:string):string が選択される
var x : Date = id(new Date());    // id(n:Date):Date は存在しないのでコンパイルエラー

```
#### インターフェイスの継承

extends キーワードを使うことで、ほかのインターフェイスを拡張した新しいインターフェイスを定義することができます。
    他のインターフェイスを拡張したインターフェイスは、もとのインターフェイスのシグニチャをすべて受け継ぎます。

```js
interface ExtendedPerson extends Person{
    phoneNumber: string;
}

```                       

#### 既存のインターフェイスの拡張

インターフェイスの重要な特長として、同名のインターフェイスを複数書くことができ、それらが単一のインターフェイスとして扱われるという性質があります。
つまり、ある既存のインターフェイスについて、そのインターフェイスにシグニチャを追加したければ同じ名前でインターフェイスを定義することでシグニチャを追加できます。

```js
interface A{
    piyo:string;    
}

interface A{
    hoge:number;
}

// A なオブジェクトは hoge, piyo を両方持っていなければならない
var a:A = { piyo:"", hoge:10  };

```


例えば、window に試験的に実装した API を使いたいときに interface Window を定義してプロパティを追加するような使い方ができるのかなと思います。
標準ライブラリの定義ファイルをいじるか、any でごまかす方法もありますけれど。


```js
interface Window{
    webkitRequestAnimationFrame(func:()=>void):void;    
}

```               

参考:

* [Walkthrough: Interfaces](http://blogs.msdn.com/b/typescript/archive/2013/01/24/interfaces-walkthrough.aspx) (en)

### サブタイピング

TypeScript はサブタイプを決定するための型システムとして **Structural Subtyping** を採用しています。
大雑把に言えば、Structural Subtyping とは『スーパークラスのすべてのプロパティさえ持っていれば、そのオブジェクトはそのスーパークラスのオブジェクトとして振る舞えるので、
直接の継承関係に関わらずそれをサブタイプとみなす』という仕組みです。例えば、次のコードで err に代入してるオブジェクトはインターフェイス Error を実装しているクラスだというわけではありませんが、name と message というプロパティさえあれば(もちろん型も一致していなければなりませんが)それは Error として問題なく扱えるので、err:Error に代入することが可能になっています。


```js
interface Error{
    name: string;
    message: string;
}

var err:Error = { name:"HogeError", message:"Unexpected Hoge!" };

```


サブタイプとなる条件はやや複雑ですが、その振る舞いはごく直感的なので実際は迷うことはあまりないと思います。サブタイプはスーパータイプのすべてのプロパティを持っているというようなオブジェクト指向の基本は、
TypeScript においても同じです。



ある型が他の型のサブタイプであるとき、その型の変数へと代入することが可能になります。サブタイプとなる条件や代入が可能となる条件は簡単に言えば次のとおりですが、厳密な条件は仕様書を参照してください( 3.6.2 Subtypes and Supertypes, 3.6.3 Assignment Compatibility )。

* any の変数にはどんな型の値でも代入できる
* any な式はどんな型の変数へでも代入できる
* null, undefined はどんな型の変数にでも代入できる
* ある型がスーパータイプのすべてのプロパティを持っていればサブタイプになる

~~ただし、クラスはそれぞれが自分の型を特定するための**ブランド**を持っており、たとえメンバの構成がまったく同じでも
ブランドが異なれば互換性はありません。
たとえば、以下の２つのクラス A と B は(Objectから継承したものを除き)どちらもメンバを持っていないので『AはBのすべてのプロパティを持っている』といえますが、a を b に代入しようとするとエラーになります。~~

**TypeScript 0.9 からはブランド関連の記述がすべて削除されており、ブランドの概念はなくなったようです。**

```js
class A{
}
class B{
}

var a : A = new A();
var b : B = a; // コンパイルエラー

```

~~extends で継承したクラスはスーパークラスのすべてのメンバを持ち、なおかつスーパークラスのブランドも引き継ぐので、そのクラスはそのスーパークラスのサブタイプとなります。~~

~~このとき、インターフェイスを経由するとブランドが取り除かれるので、a を b へと代入することができたりします。インターフェイスにはブランドがありませんから、必要なプロパティさえあればそのインターフェイスのサブタイプになることができます。~~

```js
class A{
}
class B{
}

interface I{
}

var a : A = new A();
var i : I = a;
var b : B = b;

```

(余談となりますが、Structural Subtyping は『構造的部分型』と訳す例が多いようです。ただ、"static typing" を『静的型付け』と訳すように、この "typing" は『型』ではなく『型付け』を意味しているので、訳すなら『構造的部分型付け』とでもなるようにも思います。さらに、"subtype" (部分型) にあたるものはオブジェクト指向界隈では "derived type" (派生型) と呼ぶことが一般的で、派生型と呼んだほうが親しみやすいかもしれません。ちょうどいい訳が見つからないので、ここではそのまま Structural Subtyping と呼んでおきます。意味合いとしては、『そのオブジェクトがどんなメンバを持っているかという構造に従った派生型の決定』というような意味になります。

筆者としては『部分型』というと『スーパークラスの一部分だけのメンバで構成された型』みたいに思えてしまうので、なんとなく『部分型』よりは『派生型』という呼び方のほうが好きです。
もちろん、『型』は『集合』であり、サブクラスのオブジェクトの集合はスーパークラスのオブジェクトの部分集合なので『部分型』という呼び方そのものは正しいですが、『部分型』という訳語を partial type の訳語に割り当てたいという思惑もあったりします。
)

### 型アサーション

型アサーション (type assertion) は、基底クラスの型から派生クラスの型へと式の型を変換します。いわゆるダウンキャストやナローイング変換のようなものだと思えばいいでしょう。

```js
&lt;type&gt; expression
```

というように、型を `<` と　`>` で囲んで式 expression の先頭に置くと、式 expression の型が type であると表明できます(4.13 Type Assertions)。この型は型名にかぎらずオブジェクト型リテラルでも大丈夫です。例えば Circle が Shape のサブタイプであるとき、型表明を使うと Shape である値を Circle に変換することができます。 


```js
class Shape { ... }

class Circle extends Shape { ... }

class Rectangle extends Shape { ... }

function createShape(kind: string): Shape {
    if (kind === "circle") return new Circle();
    ...
}

var circle:Circle = <Circle> createShape("circle");

``` 

型アサーションは型チェックのときにコンパイラを説得するためだけに使われ、実行時に型をチェックしてエラーを出すコードが追加されるようなことはありません。
実行時に誤った型へと変換しても実行時エラーは出ないので気をつけましょう。
たとえば、上記のコードで createShape("circle") は実行時に　Circle のオブジェクトを返しますが、
コンパイルすると型注釈や型アサーションは単に取り除かれるので、代入した時にエラーがでるようなことはありません。

```js
var rect:Rectangle = <Rectangle> createShape("circle"); 
``` 
このコードをコンパイルすると、単に以下のような JavaScript になります。
```js
var rect = createShape("circle");  
``` 

基本的にはサブタイプになり得ない型へとキャストすることはできませんが、`&lt;any&gt;` を使えばどんな型にでも自在にキャストできてしまいます。既存の JavaScript のなかには型の概念など歯牙にもかけないコードがありますが、そうしたコードを TypeScript から呼び出す場合には `&lt;any&gt;` を使わざるを得ないケースは結構あります。とはいえ `&lt;any&gt;` は型チェックがもたらす安全性を台無しにしますから、最低限の使用に限るのがいいでしょう。

### this キーワード

TypeScript の `this` はそれが書かれている場所によって意味が異なります( 4.2 The this Keyword )。

* コンストラクタ、メンバ関数、メンバアクセサにおいては、`this` はそのインスタンスを指す。
* 静的関数や静的アクセサでは、`this` はそのコンストラクタ関数を指す。
* 関数定義や通常の function 式、グローバルモジュールでは `this` は呼び出した文脈によって変わり、`this` は `any` である。

`any` となる位置では間違って参照してもコンパイルエラーが出ません。比較的ハマりやすい部分だと思うので十分気をつけましょう。特に、アロー関数式の中にある `this` の意味が変更されているのはよく理解しておいたほうがいいと思います。たとえば、以下のソースコードでは function 式を使っていますが、この中の `this` は `messenger` ではなく `window` なので、この場合は `this.message` は `undefined` になってしまいます。

```js
// 3秒後にメッセージを出力するスクリプト……？
var messenger = {
    message: "Hello World",
    start: function() {
        // おっと！this.message は　undefined 
        setTimeout(function(){ alert(this.message); }, 3000);   
    }
};
messenger.start();

```       

このようなときは、function 式を使うのではなくアロー関数式を使うと、`this` がちゃんとインスタンスを指すようになります。

```js
var messenger = {
message: "Hello World",
    start: function() {
        // this.message がちゃんと "Hello, World" になる！ふしぎ！
        setTimeout(() => { alert(this.message); }, 3000); 
    }
};
messenger.start();

``` 

なぜアロー関数式内の `this` がインスタンスを参照できるかというと、コンパイルするときに自動的にインスタンスを参照する変数 `_this` を定義して、いったん this の参照を保存しておいてからそれを参照するようにしてくれるからです。

```js
// JavaScript
var messenger = {
    message: "Hello World",
    start: function () {
        var _this = this;
            setTimeout(function () {
            alert(_this.message);
        }, 3000);
    }
};
messenger.start();

``` 

アロー関数式と従来の function 式の使い分けは難しくありません。たとえば、JQuery.each は繰り返して参照しようとするオブジェクトを this 経由で参照しますが、このような場合は `this` の意味が変更されては困るのでアロー関数式を使うことはできず、function 式を使わざるをえません。

```js
$('p').each(function(){                      // each(()=>{ ... }) のようには書けない
    var child: HTMLParagraphElement = this;  // ここで this にアクセスする必要があるため 
    ...
});
```

このように、どうしても `this` にアクセスしなければならない状況以外では、ほとんどの場合はアロー関数式を使うのがよいでしょう。たとえば、`setTimeout` のコールバック内では特に `this` にアクセスする必要はありませんので、アロー関数式を使うとコードを短く書くことができます。

```js
setTimeout(()=>{
    ...
});
```

また、クラスのメンバ関数の定義においては無名関数のネストの中でもそのインスタンス自身を参照できるので、 `this`　はクラスの定義で重宝します。

```js
class Messenger {
    message: string = "Hello World";

    start(): void {
        setTimeout(()=>{
            alert(this.message);  // アロー関数式の内側だけど、this はちゃんとインスタンスを参照する
        }, 3000);
    }
};

new Messenger().start();
```

### クラス

TypeScript にはクラスベースオブジェクト指向の機能があります。出力される JavaScript ソースコードにおいてはプロトタイプを使用してオブジェクト指向を実現しているにすぎませんが、クラスベースのように継承やオーバーライドを使用できるので記述が容易になり、可読性は高くなります。

**クラス**は **`class`** キーワードで始まり、次にクラス名を書きます。そのあとに中括弧を書き、その中にクラスのメンバを書きます。コンストラクタの名前として <span>constructor</span> という予約語を使うことにも注意しましょう。他の型を継承する場合は、クラス名のあとに **`extends`**、続けてスーパータイプ名を書きます。大まかには次のような構文になっています。

```js
class className extends superClass implements interface1, ...　{

    // クラス変数
    varName : varType = expression;

    // メンバ関数
    funcName(arg1 : arg1Type, arg2 : arg2Type, ...) : returnType　{
        ...
    }

    // コンストラクタ
    constructor(arg1 : arg1Type, arg2 : arg2Type, ...)　{
        ...
    }

    // get アクセサ
    get getAccessorName() : returnType　{
        ...
    }

    // set アクセサ
    set setAccessorName(arg : argType) {
        ...
    }

    // 静的クラス変数
    static varName : varType = expression ;

    // 静的メンバ関数
    static funcName(arg1 : arg1Type, arg2 : arg2Type, ...) : returnType　{
        ...
    }
}

```

**クラスを定義する順序には意味があり、クラスはコンストラクタを呼び出したり、ほかのクラスが継承するより前に定義しておかなくてはなりません。**例えば、クラスの定義より前にそのクラスのコンストラクタを呼び出してもコンパイルは成功しますが、実際に実行するとクラスの定義が完了していないためエラーになります。

```js
new A(); // TypeError: undefined is not a function 

class A{
}
```

このコードは以下の JavaScript へとコンパイルされます。

```js
new A();
var A = (function () {
    function A() { }
    return A;
})();
```

`A` はコンストラクタ、つまり関数なのですが、`A` へは function 式を呼び出した返り値が代入されています。従って `new A()` より以前に `A` の初期化が巻き上げられるようなことはなく、`new A()` のあとに `A` が初期化されることになります。従って `new A()` の時点では `A` は `undefined` であり、実行するとエラーになります。他にも、例えば、あるクラス A がスーパークラス B を継承するとき、A の定義が行われる前に B の定義を終えておかないと、A の定義が行われた時点でエラーになります。

```js
class A extends B{
}

class B{
    b(){
    }
}

new A().b(); // TypeError: Cannot read property 'prototype' of undefined
```

この振る舞いは JavaScript における変数の巻き上げ(Hoisting) にまつわる問題と同根で、TypeScript においてもこの問題は引き続き存在しています。このような実行時エラーの兆候は TypeScript コンパイラが検出すべきだと筆者は思いますが、これを解決するには JavaScript の変数のスコープの意味に大きな変更を加える必要があり解決は容易ではないと思われます。**クラスの定義(コンストラクタの定義)はあくまで動的に行われる**ということをよく意識しておく必要があります。型チェックはすべて静的に行われますから、型注釈や型アサーションに関してはどの順序で行ってもまったく問題ありません。

#### アクセス修飾子

メンバにはアクセス修飾子をつけることができます。アクセス修飾子は **`private`** か **`public`** のどちらかで、省略した場合は `public` になります( 8.2.1 Accessibility )。

#### メンバ変数/メンバ関数

メンバ変数は `var` キーワードは付けずにあとは通常の変数と同じように記述します。メンバ関数は `function` のキーワードは書かずに関数名、引数、本体と書いていきます。用語としては「フィールド」ではなく「メンバ変数」、「メソッド」ではなく「メンバ関数」のようです。メンバへのアクセスは、クラスの内部でも `this.` を省略することはできません。オーバーロードも可能です。

#### コンストラクタ

コンストラクタは **`constructor`** というキーワードを使用して定義します。オーバーロードも可能です。また、コンストラクタの引数に public もしくは private という修飾子をつけることができ、このときクラスには自動的に引数と同名のメンバ変数が定義されて引数の値が代入されます。これを**引数プロパティ宣言**(parameter property declaration)といいます( 8.3.1 Constructor Parameters )。クラスのメンバ変数をコンストラクタで初期化するような場面はとても多いので、思った以上に使用頻度の大きい便利な機能です。たとえば、３次元のベクトルクラスのコンストラクタで `x`, `y`, `z` の値を初期化するとき、一般的にはつぎのようにクラス変数をそれぞれ定義したり、コンストラクタでいちいち引数をクラス変数に代入するコードを書く必要があります。

```js
class Vector3{

    x:number;
    y:number;
    z:number;

    constructor(x:number, y:number, z:number){
        this.x = x; 
        this.y = y;
        this.z = z;
    }
}
```

このようなとき、引数プロパティ宣言を使うと次のようにとてもシンプルに書けます。

```js
class Vector3{
    constructor(public x:number, public y:number, public z:number){
    }
}

```

スーパークラスのコンストラクタを明示的に呼び出すには **`super`** を使います ( 8.3.2 Super Calls )。引数プロパティ定義を使用する場合は明示的な `super();` が必要になるようです。
   

#### アクセサ

get, set キーワードを使ってアクセサを定義できます(8.4.3 Member Accessor Declarations)。構文としてはクラス関数の定義に似ていますが、get アクセサは引数をとることができませんし、set アクセサは返り値の型にあたる部分を省略しなければなりません。アクセサにもアクセス修飾子をつけることができます。
アクセサは Object.defineProperty の get プロパティの定義へとコンパイルされます。デフォルトでは tsc は EcmaScript3 に準拠するコードを出力しますが、get プロパティは EcmaScript5 の機能なのでアクセサを定義するとエラーになります。アクセサを定義するにはコンパイル引数として --target ES5 を渡す必要があります。

#### オーバーライド

メンバ関数のオーバーライドも可能です。メンバ関数をオーバーライドするには、サブクラスでスーパークラスのメンバ関数と同名のメンバ関数を定義します。残念ながら C# の override キーワードや Java の @Override アノテーションのようなものはありませんので、うっかりタイプミスをするとオーバーライドしたつもりでオーバーライドできていなかったりという危険があります。くれぐれもタイプミスをしないよう気をつけましょう。また、オーバーライドを禁止することもできませんから、スーパークラスのメンバ関数の名前を変更するときは細心の注意を払いましょう。

ちなみに、なんだか妙ですが、メンバ変数のオーバーライドみたいなことも可能です。派生クラスでスーパークラスのメンバ変数と同じ名前のメンバを定義することができます。
この場合、インスタンスごとのプロパティに代入するような状況なのでいわゆる『オーバーライド』とは微妙に違いますが、Java や C# のような言語と異なりエラーにならないのが TypeScript 独特の振る舞いです。

また、そのオブジェクトのプロパティに代入することでもスーパークラスのメンバ関数の振る舞いを差し替えることができます。

```js
class Base{
    write(){
        console.log("hoge!");
    }
}

class Derived extends Base{
    constructor(){
        super();
        this.write = ()=>console.log("piyo!");  // write というプロパティがあるという扱い
    }
}

var d = new Derived();
d.write();  // Base のプロパティは隠蔽されるので、piyo! が出力される

d.write = ()=>console.log("bya!");  // もちろん外から差し替えることも
d.write();  // bya! が出力される
```                       

さらに、super やクラス名をたどればスーパークラスのメンバ関数を外部から差し替えるようなことも可能です。TypeScript のクラスも所詮はオブジェクトに過ぎないことを考えれば、このあたりのフリーダムさもある意味当然の振る舞いです。いくらクラスがあるといっても、カプセル化だとかそういうのは望むべくもありません……。

```js
class Base{
    write(){
        console.log("hoge!");
    }
}

Base.prototype.write = ()=>console.log("piyo!");

new Base().write();  // piyo! が出力される
```                       

#### super キーワード

オーバーライドされたプロパティでも、**`super`** キーワードを使えばスーパークラスのプロパティにアクセスすることが可能です。`super` キーワードはコンストラクタの節で説明したように、スーパークラスのコンストラクタを呼ぶときにも使います。
                        
#### 静的メンバ

**`static`** をつけたメンバは静的メンバになります。アクセス属性は常に `public` です。静的メンバにアクセスするときは、そのクラス内からであっても常に *`クラス名.`* の修飾が必要になります。

### 列挙型

0.9 で正式に列挙型が導入されました。列挙型の定義は **`enum`** というキーワードで始まり、中括弧の中にメンバとなる識別子をカンマで区切って列挙します。このメンバには定義した順番で整数が自動的に割り当てられますが、`=` を使って明示的にその値を指定することもできます。たとえば、トランプのスーツを列挙型を使って表すと、次のようになります。

```js
enum Suit {
    Spade,
    Heart,
    Club,
    Diamond
}
```

このように定義された列挙型はオブジェクトになっており、そのプロパティを参照することでその列挙型の値を取得することができます。これらの列挙型の値は型チェック時にはそれ独自の型として扱われますが、実際には単なる `number` です。列挙型の値は暗黙に `number` 型へと変換できますので、 `==` で等値性を比較したり `&lt;` で大小関係を比較することができます。

```js
console.log(Suit.Spade == Suit.Heart);  // false

console.log(Suit.Spade &lt; Suit.Heart); // true
```

列挙型のオブジェクトは数値をキーとしたプロパティも持っており、これらプロパティにはその値をもつ値の名前が文字列として格納されています。次のようにすれば、列挙型の値からその文字列表現を取得したり、文字列から対応する列挙型の値を取得することが可能です。

```js
console.log(Suit[0] === 'Spade');  // Suit[0] は 'Spade' なので true

console.log(Suit[Suit.Spade] === 'Spade');  // true

console.log(Suit['Spade'] === Suit.Spade);  // 配列としてアクセスしてももちろん構わない。true
```

列挙型の値すべてをリストとして取得するような機能はないようです。要素すべてについて繰り返すには、次のように for 文で繰り返すか、[linq.js](http://linqjs.codeplex.com/) の `Enumerable.RangeTo` みたいなのを使うといいかもしれません。

```js
for(var i: Suit = Suit.Spade; i &lt;= Suit.Diamond; i++){
    console.log(Suit[i]);
}
```

* 参考: [Announcing TypeScript 0.9](http://blogs.msdn.com/b/typescript/archive/2013/06/18/announcing-typescript-0-9.aspx)

### モジュール

TypeScript のモジュールは、内部モジュールと外部モジュールというふたつの機構があります。

#### 内部モジュール

**内部モジュール** (Internal Module) は TypeScript 自身に用意されたモジュール機能です。
内部モジュールは、単なる名前空間や Java のパッケージとは少し趣が異なり、どちらかというとシングルトンのオブジェクトと考えるのが近いと思います。
JavaScript にはモジュールがないので、モジュールに相当するオブジェクトを用意しそのプロパティとしてモジュールに含められるべき関数や変数を定義し、そのオブジェクトを介して関数や変数にアクセスすることでモジュールのようなものを実現しようとすることがよくありますが、TypeScript のモジュールはそのような機構をより直感的、抽象的に扱えるようにしたものです。

モジュールを定義するとその名前の変数が定義されたことになりますし、同時に同名の型が定義されることにもなります。
モジュールにはクラスやインターフェイスはもちろん、関数や変数、ほかのモジュールをも含むことができますし、任意の式や文も含めることができます。
モジュール内部に含められたこれらの要素はモジュールが読み込まれたときに実行されますので、モジュールを定義する順序にもある程度気を遣う必要があります。

モジュールの定義は module キーワードで始まります。その後モジュール名を書き、そのあとの { } の中でモジュールの要素を定義します。

```js
module moduleName {
    var varName: varType = expression;

    function funcName(arg1: arg1Type): returnType{
        ...
    }

    class className{
        ...
    }

    module nestedModule{
        ...
    }
}

```

ひとつの内部モジュールはひとつのファイル内だけで定義する必要はありません。
必要なら２つ以上のソースファイルで別々に同名のモジュールを定義しても構いません。
その場合、ソースファイルを両方コンパイルして、出力された JavaScript を両方読みこむようにすればちゃんと動作します。


#### モジュールメンバのエクスポート

モジュール内の関数やクラスは、デフォルトではそのモジュール内のみで参照可能です。これを外部から参照可能にするには、
そのメンバの先頭に export キーワードを付けます。

```js
module M{
    class T{
    }

    export class S{
    }
}
var t : M.T;  // T はエクスポートされていないので、コンパイルエラー
var s : M.S;  // S はエクスポートされているので M.S で参照できる 

```

また、スクリプトのトップレベルのメンバについては、内部モジュールのメンバとしては自動的にエクスポートされます。
上記の例でいえば、M は自動的にエクスポートされるので export はつけません(以下に説明するように、トップレベルのメンバに対する export は
そのメンバを内部モジュールのメンバではなく外部モジュールのメンバとしてエクスポートすることを意味しますので、モジュール内部のメンバにつける export とは意味が異なります)。

                    
#### 外部モジュール

**外部モジュール** (External Module) は CommonJS や Asynchronous Module Definition (AMD) が定める仕様に従ってモジュールをエクスポート/インポートする仕組みです。
外部モジュールとしてコンパイルしたモジュールは CommonJS や AMD に従った node.js のような環境で JavaScript から呼び出すことができますし、CommonJS や AMD のモジュールを TypeScript のモジュールとして参照することができます。
TypeScript が外部モジュールとしてどちらの仕様を選択するかは、コンパイルオプションで指定することができます。

外部モジュールを理解しようとする場合、それがどのような JavaScript へコンパイルされるのかをみるのがもっともわかりやすいでしょう。CommonsJS のモジュールとしてコンパイルする場合を例にとって説明します。
たとえば、つぎのような message という関数が定義された log.ts というファイルがあったとします。

```js
// log.ts
function message(s: string) {
    console.log(s);
}
```

この mesｓage という関数はコンパイルしても CommonsJS 形式のモジュールとしてエクスポートされず、
CommonsJS のモジュールや TypeScript の外部モジュールの要素として参照できません。
これを CommonsJS のモジュールの要素としてエクスポートするには、その要素の先頭に export というキーワードをつけます。この export は関数や変数、クラスなどにつけることができます。


```js
// log.ts
export function message(s: string) {
    console.log(s);
}
```

デフォルトだと、export を付けたこの log.ts は commonsjs の仕様に従って、つぎのようなコードへとコンパイルされます。
message という関数が定義されるだけでなく、exports というオブジェクトにエクスポートしたい message がプロパティとして代入されているのがわかります。こうすると CommonJS のモジュールの要素として message をエクスポートすることができます。

```js
// log.js
function message(s) {
    console.log(s);
}
exports.message = message;
```

このJavaScript ソースファイルは CommonJS 形式のモジュールになっているので、これをTypeScriptの log という外部モジュールとして読み込むことができます。CommonsJS や AMD 形式のモジュールを TypeScript の外部モジュールとしてインポートするには、次のように import modulename = module('modulepath'); というように書きます。こうすると、modulename がそのモジュールのオブジェクトとして参照することができます。

```js
// main.ts
import log = module("log");
log.message("hello");
```

この main.ts は単に次のようなコマンドでコンパイルすることができます。

```bash
tsc main.ts
```

log.ts や log.js をコンパイル引数に与えたりはしていませんが、コンパイラは import log = module("log"); という行から自動的に log というモジュールへの依存性を解決してくれます。この main.ts は CommonJS の仕様に従って、require("./log") という関数を呼び出すコードにコンパイルされます。


```js
// main.js
var log = require("./log")
log.message("hello");
```

##### Export アサインメント

CommonJS や AMD のようなモジュールに関する仕様では、どんなオブジェクトでもモジュールとしてエクスポートすることが可能になっています。TypeScript の外部モジュールの定義でもエクスポートするオブジェクトを柔軟に定義できるように、TypeScript 0.9 から `export =` というような構文が導入されました(**11.2.4 Export Assignments**)。`export = ` の直後には任意の識別子を書くことができます。例えば、クラス名を書けばそのクラスをモジュールがエクスポートするオブジェクトとすることができます。次のサンプルでは `export =` を使ってクラスをモジュールとしてエクスポートしています(言語仕様からの引用です)。

```js
export = Point; 

class Point { 
    constructor(public x: number, public y: number) { } 
    static origin = new Point(0, 0); 
}
```

エクスポートされたオブジェクトは `require` を使ってインポートできます。

```js
import Pt = require("point.ts"); 
var p1 = new Pt(10, 20); 
var p2 = Pt.origin;
```

* 参考: [Announcing TypeScript 0.9](http://blogs.msdn.com/b/typescript/archive/2013/06/18/announcing-typescript-0-9.aspx)

#### モジュールの別名

モジュールはしばしば `Foo.Bar.Baz` のように深くネストすることがありますが、毎回 `Foo.Bar.Baz.AnyClass` のように書くのは面倒です。このようなときには、**`import`** キーワードでモジュールに別名をつけることができます。

```js
import Qux = Foo.Bar.Baz; 
```

このようにすると、そのファイル内で `Qux.AnyClass` のようにクラスや関数を参照することができます。

### アンビエント宣言

**アンビエント宣言**(Ambient declarations)は関数やクラスのシグニチャだけを定義するもので、主に既存の JavaScript に型注釈を付け加えるときに使います。C言語の extern のようなものです。変数や関数の定義のとき、declare キーワードを先頭につけて本体や初期化部分を省けば、それはアンビエントの定義になります(インターフェイスの場合はもとから本体がありませんから、declare をつけても何も変わりません)。アンビエント定義された変数や関数をそのファイル内で参照することはできますが、コンパイルして出力されるファイルには影響しません。

```js
declare function hoge():void;

declare var piyo:string;

declare class Foo{
    method():void;
    field:string;
}

declare interface Bar{
    baz:number;
}
```

アンビエント宣言は型チェックの解決に使われるだけなので、実際の JavaScript の実装と必ずしも一致してる必要はありません。筆者は number である変数を列挙型のシンボルとみなして列挙型として定義したり、存在しないクラスを抽象クラスとして追加してしまったりとアンビエント宣言では結構大胆な使いかたをしています。

**宣言ソースファイル**(declaration source files )はアンビエント宣言のみが書かれたファイルです。定義ソースファイルは拡張子を .d.ts にします。通常の .ts ファイルでは declare キーワードをつけたシンボルだけがアンビエント宣言になりますが、定義ソースファイルではすべてのシンボルが自動的に declare をつけたものだとみなされます。既存の JavaScript ライブラリに型注釈を加えて使う TypeScript から使う場合は、その型注釈は宣言ソースファイルに分離しておくほうが使いまわしがしやすくなると思います。

### ジェネリクス

TypeScript 0.9 でついにねんがんのジェネリクスが導入されました。TypeScript のジェネリクスはおおむね Java などの構文によく似たものになっているようで、すでに Java などを使っているかたならまったく違和感なく使えると思います。[Working on TypeScript 0.9: Generics, Overload on Constants and Compiler Performance](http://blogs.msdn.com/b/typescript/archive/2013/03/25/working-on-typescript-0-9-generics-overload-on-constants-and-compiler-performance.aspx) で紹介されている内容や仕様書の記述、筆者が実際にコンパイルを試した結果を簡単にまとめておきます。

試したコンパイラのバージョンは 9868d68c9e98180608f2bb736894f2a7ce85a8dd の develop ブランチです。`typescript/tests/cases/compiler/` あたりのディレクトリにユニットテストのテストケースがたくさん入っていますので、これをのぞくとどんなコードが通るのかある程度わかります。

#### 関数の型パラメータ

引数の括弧の直前で型パラメータを `&lt;` と `&gt;` の間に書くことで型パラメータの宣言ができます。関数の型パラメータは引数から推論できる場合は自動的に推論されますが、それができない場合は明示的に指定する必要があります。

```js
// 配列の最初の値を取り出す関数。Array&lt;T&gt; は T[] のエイリアス
function head&lt;T&gt;(array:Array&lt;T&gt;): T {   
    return array[0];
}

var num: number = head&lt;number&gt;([10, 20, 30]); // 明示的に型パラメータを与えた場合

var str: string = head(["red", "blue", "yellow"]);  // 引数から推論できるので、型パラメータを省略できる
```

#### クラスの型パラメータ

クラス名のすぐ後ろに型パラメータを書きます。

```js
class Tree&lt;T&gt; {
    left: Tree&lt;T&gt;;
    value: T;
    right: Tree&lt;T&gt;;
}
```

#### インターフェイスの型パラメータ

インターフェイス名のすぐ後ろに型パラメータを書きます。

```js
interface Comparable&lt;T&gt; {
    compare(t: T): boolean;
}

class Tuple&lt;T,S&gt; implements Comparable&lt;Tuple&lt;T,S&gt;&gt; {
    constructor(public fst: T, public snd: S){
    }

    compare(t: Tuple&lt;T,S&gt;): boolean {
        return this.fst === t.fst && this.snd === t.snd;
    }
}


// オブジェクト型リテラルには型パラメータを宣言できないようです。
// 型パラメータを宣言するにはいったんインターフェイスとして定義する必要がありそうです。
// var hoge: &lt;T&gt;{ t: T; };
```

#### アロー関数式の型パラメータ

先頭で型パラメータを宣言することで、アロー関数式でも型パラメータを使えます。

```js
var id = &lt;T&gt;(t: T)=&gt;t;
```

#### 型パラメータの制約

`extends` でほかの型を指定することで、その型パラメータに制約を加えることができます。

```js
interface Show {
    show(): string;
}

function showArray&lt;T extends Show&gt;(xs: Array&lt;T&gt;){
    for(var i: number = 0; i &lt; xs.length; i++){
        var e: T = xs[i];
        console.log(e.show());  // T は Show を実装しているので show を呼べる
    }
}

```

#### 型パラメータと関数のオーバーロード

オーバーロードされた関数の定義でも型パラメータを宣言できます。その場合、各シグニチャは独立しているので、宣言されたそのシグニチャの中だけでその型パラメータを使うことができます。

```js
function parse&lt;T&gt;(parser: Parser&lt;T&gt;, input: string): State&lt;T&gt;;
function parse   (parser: string,    input: string): State&lt;string&gt;;   
function parse   (parser: any,       input: any)   :　any {
    ...
}
```

#### 変な型の型パラメータ

この変なコードのコンパイルが通ってしまうのは、さすがにバグっぽい気がします。

```js
class Tuple&lt;T,S&gt; {
    constructor(public fst: T, public snd: S){
    }
}

var t: Tuple&lt;void, undefined&gt; = new Tuple&lt;void,undefined&gt;(undefined, undefined);

function foo(): void {

}

t.fst = foo();
t.snd = 10;
```

#### バグ

まだかなりバグは多いです。TypeScript 先生の次回作にご期待ください！

```js
// s の型を間違えてる。二つ以上型パラメータがあると混乱しやすい？
class A&lt;T,S&gt; {
    s: S;
    f(t: A&lt;T,S&gt;): boolean {
        return this.s === t.s;     // error TS2009: Operator '===' cannot be applied to type 'S' and 'T'.
    }
}
```

```js
// 関数型リテラルの型パラメータ。パーサは通っているようだけど型チェックに失敗
var id: &lt;T&gt;(t: T)=&gt;T = &lt;T&gt;(t: T)=&gt;t;  // error TS2095: Could not find symbol 'T'.
```

### 他のスクリプトの参照

ある TypeScript ソースファイルからほかのソースファイルのモジュールや関数などを参照するには、単純にコンパイル引数に必要なファイルをすべて列挙する方法もありますが、次のような特別なコメント行を書いておくことでソースファイルに他のファイルへの依存関係を書いておくことができます(9.1.1 Source Files Dependencies)。

```js
/// &lt;reference path="hoge.d.ts" /&gt;
```

これは宣言ソースファイルを参照するときにもよく使われます。たとえば、jquery の宣言ソースファイル jquery.d.ts を使いたいなら、そのソースファイルの先頭に次のようなコメントを書いておきます。

```js
/// &lt;reference path="jquery.d.ts" /&gt;

$('#hoge').html('hogehoge');     // $ が使える！
```

この場合、あくまで jquery.d.ts をシンボルの解決のために参照しただけで、コンパイル後の JavaScript に jquery.js のファイルが勝手に追加されるようなことはありません。html にちゃんと jquery を読み込むような JavaScript を書いておく必要があります。



依存先のソースファイルが宣言ソースファイルではなく通常のソースファイルである場合は依存先のファイルもコンパイルされますし、単一のファイルへと結合する　--out オプションを指定すると依存先のファイルのコンパイル結果もすべてまとめて出力してくれます。


### Source Map

Source Map は、もとのソースコードとコンパイル後の JavaScript ソースコードの対応関係を記録しておいて、デバッガでもとのソースコードを見ながらブレークポイントを仕掛けたりステップ実行したりできる機能です。TypeScript もこれに対応しており、--sourcemap オプションをつけてコンパイルすると、.map という拡張子がついたファイルが出力されます。また、出力された .js の最後に 


```js
//@ sourceMappingURL=hoge.js.map
```


というようなコメント行が追加されているのが確認できると思います。Chrome の場合、開発者ツールを起動したら右下の歯車のボタンを押し、その中の General タブ → Source → Enable source maps というチェックボックスにチェックを入れると sourcemap が使えるようになります。Source タブのソースコード一覧に .ts ファイルが現れますから、あとは通常の JavaScript と同じようにデバッグできます。ただし、いまいち挙動に不審なところがあったりして、うまくブレイクポイントを仕掛けられなかったりします。
TypeScript は最も sourcemap と相性のいい言語のひとつではありますが、それでも 100% 対応関係が取れるわけではないでしょうから、sourcemap に頼りすぎるのは禁物です。
筆者はしばらく Source Map 使ってましたけど、結局不具合が多くて普通に JavaScript でのデバッグに戻りました……。



### ドキュメントコメント

javadoc/jsdoc スタイルのソースコードインラインドキュメントに一部対応しました。
VisualStudio のエディタで型名などにカーソルを合わせると、ツールチップに対応するドキュメントが表示されます。
0.8.2 の時点ではタグは @param にしか対応していません。



```js
/**
* Converts A string to an integer.
* @param s A string to convert into a number.
* @param radix A value between 2 and 36 that specifies the base of the number in numString. 
* If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.
* All other strings are considered decimal.
*/
declare function parseInt(s: string, radix?: number): number;

```

参考:
    
* [Announcing TypeScript 0.8.2](http://blogs.msdn.com/b/typescript/archive/2013/01/21/announcing-typescript-0-8-2.aspx) (en)
    

### 今後の言語仕様の変更について

[TypeScript のロードマップ](http://typescript.codeplex.com/wikipage?title=Roadmap)が公開されており、今後どのような言語仕様が追加されるかが大まかにわかるようになっています。このうち幾つかについて紹介しておきます。TypeScript の言語仕様のかなりの部分が　EcmaScript の仕様に基づいているので、今後の TypeScript の動向を探るうえでは EcmaScript の動きも追っておくといいかもしれません。また、現在検討されている言語仕様については[Design Notes](http://typescript.codeplex.com/wikipage?title=Design%20Notes) が参考になるほか、[Issue Tracker](http://typescript.codeplex.com/workitem/list/advanced) や [Discussions](http://typescript.codeplex.com/discussions/topics/5488/language-specification)を探してみると議論が見つかります。

* Generics - パラメタライズされた型を定義できるようになります。例えば、配列の型は `Array&lt;T&gt;` のように型パラメータとともに表されるようになります。このとき T は配列の要素を表しており、number のみを要素に持つ配列の型は `Array&lt;number&gt;` と表されます。 コレクションに限らず使い道の多い重要な機能です。これが導入されると lib.d.ts を始めありとあらゆるコードに影響するので、おそらく今後行われるであろう変更のうち最も大きいものとなると思います。
* Async/Await - 非同期処理を書きやすくする機能です。JavaScript は非同期処理が原則になっており、時間のかかる処理では処理をリクエストしておいて、完了するとイベントとして完了が通知されるような設計になっています。これはこれで便利な時もありますが、処理があちこちに飛ぶことになりやすく直感的に読みにくいコードになりがちです。await を使うと同期的な処理を行なっているかのように処理の流れに沿って自然に記述できるようになり、可読性も増します。ES6 でも採用が決定されているわけではありませんが導入が検討されているようです。
* Mixin - 多重継承の問題のようなもの起こさずにコードの再利用を行える仕組みのようです。筆者は Mixin のある言語をほとんど使ったことがないので、あまり詳細には解説できません。Perl/Ruby/Python, Scala あたりでよく使われているようなので、詳しくはそちらの解説を探してみるといいんじゃないかと思います。
* Protected access - おそらくですが、アクセス修飾子に public と private に加えてサブクラス内からのみ参照可能であることを指定する protected が追加されるということでしょう。

   
## ケーススタディ
ここではさまざまなケースを例にとって TypeScript の扱い方を解説していきます。

### API を確認する

それで、『言語仕様はわかったけれど、TypeScript の標準ライブラリにはどんなクラスが用意されているの？』と思った方もいるかもしれませんが、**TypeScript には独自の標準ライブラリというものは存在しません。**静的型付け以外は全部 JavaScript と同じだと考えてください。ですから API リファレンスにしろ Web 上なんかのサンプルコードにしろ、大抵の場合は JavaScript のものをそのまま流用できます。

とはいえ、実際にコーディングしていると何かうまく型が合わなかったり、あるはずのプロパティが見つからなかったりということもあるでしょう。その場合は定義ソースファイルを直接確認する必要も出てきます。
TypeScript コンパイラはデフォルトで自動的に HTML DOM や JavaScript の標準ライブラリの定義ソースファイルを読み込みます。筆者の Windows8 の環境だと `C:\Users\【ユーザ名】\AppData\Roaming\npm\node_modules\typescript\bin` に lib.d.ts がありました。このファイルは TypeScript コンパイラのソースコードの typings　というディレクトリにも入っています。

このファイルを覗くと、たとえば Number の定義は次のようになっています。

```js
interface Number {
    toString(radix?: number): string;
    toFixed(fractionDigits?: number): string;
    toExponential(fractionDigits?: number): string;
    toPrecision(precision: number): string;
}

declare var Number: {
    new (value?: any): Number;
    (value?: any): number;
    prototype: Number;
    MAX_VALUE: number;
    MIN_VALUE: number;
    NaN: number;
    NEGATIVE_INFINITY: number;
    POSITIVE_INFINITY: number;
}
```

lib.d.ts はデフォルトで自動的に読み込まれますが、なにか都合がわるい時には --nolib コンパイラオプションで読み込まないようにもすることができます。
JavaScript は Web クライアントだけで使うわけではないので、たとえば他のアプリケーション組み込みのスクリプト言語として使っている場合は HTML DOM の API は邪魔です。
そのような場合は --nolib をつけるといいでしょう。

### 分割されたファイルのコンパイル

プロジェクトが大きくなってくると単独のソースファイルにすべてのコードを書くのは難しくなってきます。
分割されたファイルからなるプロジェクトをコンパイルするには、単純にすべてのファイルへのパスをコンパイル引数としてコンパイラに与えればよいですが、毎回コンパイル引数にすべてのファイルを入力するのはさすがに面倒です。べつにシェルスクリプトや [jake](https://github.com/mde/jake)、[grunt](http://gruntjs.com/) のようなビルドツールでビルドしてもいいと思いますが、tsc には @filepath というコンパイルオプションででテキストファイルへのパスを与えると、そのファイルの内容をコンパイル引数として認識してくれるという機能があります。なので、例えば hoge.ts と piyo.ts という２つのファイルがあるとき、

```
hoge.ts piyo.ts
```

というようなテキストファイルを書いておき(これを options.txt としておきます)、コンパイルするときには

```bash
tsc @options.txt
```

のようにコンソールに入力すれば簡単に複数のファイルをコンパイルできるようになります。

また、前述の外部モジュールのインポートでも外部モジュールへの依存関係を示すことができます。コンパイラは import hoge = module('modulename'); のような行を見つけると、そのファイルも依存関係に追加してコンパイルしてくれます。

複数のソースファイルをコンパイルすると、デフォルトではどれぞれ .ts と同名の .js が出力されます。tsc はこれらの .js を読み込むための HTML まで出力したりはしないので、自分で適宜 .js を読み込むように HTML を書いておく必要があります。

--out オプションで出力するファイルを指定することができ、この場合は入力されたすべての .ts のコンパイル結果は、指定された順番で単一の .js へと結合されて出力されます。JavaScript においても言えることですが、TypeScript が結局は JavaScript に依存している以上、ソースファイルのロードの仕組みは JavaScript で実現できる以上の機能はありません。
JavaScript に外部ファイルのインポートの機能がないので、ビルドするときにファイルをすべて結合してしまうことはよくありますが、
TypeScript においてもファイルをすべて結合してしまうのがもっとも手っ取り早い解決策かもしれません。

全部自分で書いたソースファイルならこれでもなんとかなるのですが、問題になってくるのは自分以外の第三者が書いたソースファイルを参照する場合です。特に、ほかの人が書いた宣言ソースファイルを参照して既存の JavaScript ライブラリを呼び出すという場面は多いと思いますが、この場合は単に自分の使いたい宣言ソースファイルへのパスをコンパイル引数に与えるだけではうまくコンパイルできないときがあるかもしれません。なぜなら、その使いたい宣言ソースファイルが、さらに別の宣言ソースファイルを必要としている場合があるからです。必要なソースファイルがさらにどのファイルを必要としているか調べてコンパイル引数に加えるのはなかなか面倒ですから、なるべく自動的に依存関係を解決できるようにしておきたいです。
そのような場合は、こまめに reference path を書いておくといいでしょう。

0.82 まででは、このコメントに書いたパスにファイルが見つからなかったとしてもそれについては何のエラーも警告も出ないという欠陥がありましたが、0.8.3 から、依存先のファイルが見つからないとちゃんとエラーが出るようになりました。これで reference path がそれなりに使いやすくなったので、積極的に書いていくといいと思います。ただし、現時点での reference path には[もうひとつ大きな欠陥](http://typescript.codeplex.com/workitem/616)があります。あるファイルで依存先のファイルが reference path で指定されていると、他のファイルでもその reference path で依存関係が解決されてしまうのです。とにかく見つかりさえすればいいのならこれで何も問題ないように見えますが、tsc で複数のファイルを単一のファイルへと結合する時に困ることがあります。他のファイルに依存先が書かれていればコンパイルできてしまうのですが、そのときファイルごとの依存関係は正確に解決されていないので、結合する際のファイルの順序が意図したものとは異なる可能性があります。その場合コンパイル時にエラーは出ませんが、実行時に初期化されていないモジュールなどを参照することになり、実行時エラーになる可能性があります。たとえば、次の２つのファイルがあったとします。

```js
// hoge.ts
/// &lt;reference path="piyo.ts" /&gt;
var hoge = "hoge";
```

```js
// piyo.ts
console.log(hoge.charAt(0));
```

piyo.ts では変数 hoge を参照しているので、実際には piyo.ts は hoge.ts に依存しており、piyo.ts より先に hoge.ts を読み込まなければなりませんが、hoge.ts のほうには、誤って piyo.ts への参照が書かれています。このとき、tsc --out out.js hoge.ts でコンパイルすると、コンパイルは成功して次のような JavaScript が出力されます。

```js
console.log(hoge.charAt(0));
var hoge = "hoge";
```

hoge.ts が piyo.ts に依存していると誤って指定されたため、hoge.ts が先に出力されています。このため、１行目の時点では hoge は undefined ですから、このプログラムの実行は失敗します。piyo.ts のほうには hoge.ts への依存関係が書かれていないので hoge が見つからないというコンパイルエラーになるのかとおもいきや、コンパイラはすでに hoge.ts を知っているのでコンパイルが通ってしまうわけです。このようなトラブルを確実に回避するためには、コンパイル引数でファイルの順序を正しく指定する方法もありますが、ソースファイルの依存関係はコンパイラが調べてきっちり解決し、問題があるならコンパイラがちゃんと報告するべきで、コンパイル引数やら makefile やらに書くようなものではないと筆者は思っています。

他の解決策として、必要なスクリプトがすべて読み込まれるまで実行を遅延させる方法があります。どんな場合でも使える手というわけではありませんが、これでごまかせることも多いとは思います。

```js
// piyo.ts
/// &lt;reference path="jquery.ts" /&gt;

$(()=>{
    console.log(hoge.charAt(0));    
});
```

### 既存の JavaScript を TypeScript から利用する

もし既存の JavaScript ライブラリを TypeScript から使いたいと思ったら、まず　[borisyankov/DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped)　を探してみるといいでしょう。DefinitelyTyped は著名な Javascript ライブラリの環境定義ファイルを収集しており、underscore.js や backbone.js のような著名なライブラリの環境定義ファイルはここですぐ見つかります。とはいえ、TypeScript のコンパイラの仕様変更にあってすでにコンパイルが通らなくなっている定義ファイルもあったり、当然定義ファイルが間違っている場合もあります。実用的にはもとの JavaScript の仕様を確認し適宜定義ファイルを修正しながら開発を続ける必要があるかもしれません。筆者がやっつけ仕事で作った [DefinitelyTyped の API リファレンス](http://phyzkit.net/docs/) もありますので、ご参考までにどうぞ。

また、[tsd](http://www.tsdpm.com/) という node.js のコマンドラインからアンビエント宣言ソースファイルのインストールが可能なツールが公開されています。
DefinitelyTyped のファイルはすべてそこからインストールすることも可能になっています。また、DefinitelyTyped のファイルは [nuget](http://nuget.org/packages?q=DefinitelyTyped) のパッケージとしても入手可能になっています。最初は　DefinitelyTyped を全部 git clone しちゃったほうが手っ取り早いかなと思っていましたが、DefinitelyTyped　もそれなりの勢いで増えているので、アンビエント宣言が今後さらに増えてくるとこういうパッケージマネージャの有用性も拡大すると思います。

ちなみに、JQuery などの著名なライブラリははすでにコンパイラのソースコードにも含まれています。たとえば、 JQuery なら typings/jquery.d.ts というのがそのファイルです。[コンパイラのソースコードごとダウンロード](http://download-codeplex.sec.s-msft.com/Download/SourceControlFileDownload.ashx?ProjectName=typescript&amp;changeSetId=d397c54a55db)してもよいし、[ここ](http://typescript.codeplex.com/SourceControl/changeset/view/fe3bc0bfce1f#typings/jquery.d.ts)から個別に持ってきてもいいでしょう。あとは適当な場所に保存して、コンパイラが見つけられるように依存関係をソースコードに書いておきます。コンパイルしたあとも、実行するときは実際の jquery の JavaScript ソースファイルを読み込むのを忘れずに。jquery そのものの使い方は JavaScript から使う時とまったく同じなので、jquery に慣れていれば特に迷うことはないでしょう。jquery.d.ts の使い方を知りたければ、JavaScript で情報を探せば OK です。

### 宣言ソースファイルを書く

既存の JavaScript を呼び出したいときに、すでに誰かが書いた宣言ソースファイルが公開されていてそれを使えればいいのですが、そうでない場合は自分で宣言ソースファイルを書く必要があるでしょう。通常のソースファイルに書いてもいいのですが、その場合はいちいち declare をつけるのが面倒ですし、他のプロジェクトでそれを再利用したい場合もあるでしょうから、素直に .d.ts の宣言ソースファイルにファイルに分けて定義しておくほうが楽だと思います。

モジュールのない JavaScript といえど、実際にはまるでモジュールがあるかのように Foo.Bar.Baz のように関数やコンストラクタを参照するように既存のコードが作られている場合も多いかと思います。こうした構造を TypeScript でも自然にモジュールとして扱えるほうが便利でわかりやすいでしょう。このような場合は、宣言ソースファイルでこれらの要素をモジュール内の要素として宣言ソースファイルを書くとよいと思います。

自分が試した例で言うと、たとえば [box2dweb](http://code.google.com/p/box2dweb/) のライブラリは C++ や ActionScript を元に移植されたため、モジュールがあるかのように参照されるようになっています。たとえば、2次元ベクトルクラス b2Vec2 をインスタンス化するとき、

```js
var v = new Box2D.Dynamics.b2Vec2();
```

というように書くようになっています。JavaScript ではこの "Box2D" は単なるオブジェクトですが、モジュールのある TypeScript ではモジュールとして定義するのが自然です。
したがって、次のようにクラス b2Vec2 が Box2D.Dynamics というモジュール内にあるものとして定義しました。

```js
// box2dambient.d.ts
module Box2D.Dynamics{
    class b2Vec2{
        ...
    }
}
```

このとき、もちろん

```js
module Box2D{
    module Dynamics{
        class b2Vec2{
           ...
        }
    }
}
```

のようにモジュールをネストして定義しても、意味としてはまったく同じです。
Box2D 以下に複数のモジュールがあるような場合では、後者のほうが何度も "Box2D."と書かなくていいので多少楽ですが、
前者のほうがネストが浅くてすみます。

この b2Vec2 クラスを使うときは、

```js
var v : Box2D.Dynamics.b2Vec2 = new Box2D.Dynamics.b2Vec2();
```
                

のようにかけます。ただこのままではすべての場所で完全名でクラスを参照しなければならず、面倒です。
そこでクラスの別名が欲しくなるわけですが、JavaScript のように単なる変数として別名を定義してもうまくいきません。

```js

// b2Vec2 の別名のつもり……
var b2Vec2 = Box2D.Dynamics.b2Vec2; 

// コンパイルエラー。b2Vec2 というコンストラクタはあっても b2Vec2 という型はない
var v : b2Vec2 = new b2Vec2(); 
```
                

コンストラクタの呼び出しだけならできるのですが、b2Vec2 は単なる変数で型の名前空間にあるわけではなく、
型注釈の位置では使うことができません。かと言って直接クラス名の別名を定義する機能はないようです。
このような場合、import キーワードでモジュールの別名を定義することはできるので、これを使うと少しは楽なのではないかと思います。
    
```js
import B2D = Box2D.Dynamics;
var v : B2D.b2Vec2 = new B2D.b2Vec2();
```
    

### 予約語との衝突の回避

TypeScript では JavaScript の予約語に加えていくつかの予約語が追加されます。interface や public あたりは JavaScript でも予約されているので衝突は起きないはずですし（strict モードでなければエラーにはならないみたいですが……もちろん予約語は使ってませんよね？）、TypeScript で追加される予約語でも any や constructor あたりは問題になりません。
これらのトークンはちゃんと文脈によって解釈されるので、変数名やクラス名にも普通に使えます。

```js
// まさにカオス
var any: any = 10;    
class constructor{   
}
new constructor();   
var number:any;
class module{
}
module interface{
}
interface declare{
}
interface implements extends declare{
}
```

ちょっと気を付けなければならないのが module あたりのキーワードです。module は JavaScript の予約語になっていませんし、モジュールの定義では行頭に module が来るので、そのまま書こうとするとエラーになる場合があります。

```js
var module = 10;        

module = 10;                // Error! Expected '{'
```

とくに、node.js の module オブジェクトにアクセスしたいときにそのままではアクセスできないので、ちょっとだけ焦ります。このような場合、式の文脈で "module" をパースさせればいいので、括弧で囲むという回避策があります。

```js
var module = 10;        

(module) = 10;              // OK!
```

### 空の列挙型

筆者は three.js というライブラリの宣言ソースファイル three.d.ts を書いているのですが、
このライブラリでは定数のシンボルがオブジェクトで分けられていないのが TypeScript 的にはちょっと厄介なところです。
どういうことか例を上げて詳しく説明しておきますと、
three.js には THREE というオブジェクトがあり、これが three.js のすべてのプロパティや関数を保持しており、これがつまり three.js 全体のモジュールに相当します。
また、three.js には THREE.Material というオブジェクトがあり、このオブジェクトのプロパティ side は次の3つの定数のうちのどれかをとります。

```js
// three.js 
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
```

```js
var material:THREE.BasicMaterial = new THREE.BasicMaterial();
material.side = THREE.FrontSide;  // こういうふうに使う
```


これらの定数シンボルはつまり列挙型のメンバに相当し、本来なら列挙型を用いて定義されるべきでしょう。しかし、THREE はあくまでモジュールであり、他の関数やクラスといったメンバも含まれているので、これを列挙型として定義するのは不可能です。かといって、

```js
module THREE{
    ...

    enum Side {
        FrontSide  = 0,
        BackSide   = 1,
        DoubleSide = 2
    }

    ...
}
```

と定義すると、Side というオブジェクトのメンバとしてシンボルが定義されてしまい、たとえば FrontSide は THREE.Side.FrontSide とアクセスしなければならなくなり、これもうまくいきません。仕方ないので、three.d.ts ではこの問題を次のように空の列挙体 THREE.Side を定義することで切り抜けています。


```js
module THREE{
    ...

    enum Side {}
    FrontSide:Side;
    BackSide:Side;
    DoubleSide:Side;

    ...
}
```


この場合、THREE.Side という列挙型にはメンバがひとつもないので、THREE.Side であるような値はどこにも存在しないはずですが、THREE.FrontSide も THREE.BackSide も THREE.Side という型になっています。よく考えると結構変ですが、これが案外とちゃんと列挙型として機能することがわかったので、three.d.ts で多用しています。
でもこの方式にも欠点があって、

```js
THREE.FrontSide = THREE.BackSide;
```

のようなコードが通ってしまう危険が残っています。本当はこれらの定数を readonly にしたいところですが、TypeScript に readonly が導入される気配はあまりないです……。
とはいえ、現時点では TypeScript の enum は

```js
enum Side{
    Front,
    Back
}
Side.Front = Side.Back;
```

のようなコードが通ってしまうので、実はその危険性は列挙型にした場合と大差ありません(いや、この enum の挙動は明らかにダメダメだと思うんですけど、TypeScript では readonly はあまり重視されていません。こういうところは TypeScript はダメダメです)。

### Error の継承

Stack Overflow に [Error を継承してカスタムな例外クラスをつくりたいんだけど](http://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript) 、という質問があるようですが、JavaScript は Java と違って Error のサブタイプじゃないと例外オブジェクトとして投げられないということはないので、独自の例外クラスを作りたいからといって別に Error を継承する必要はないと思います。とはいえ、Error は確かに存在しているのでこれを継承したい、というケースもあるのかもしれません。ですが現時点の lib.d.ts では Error はインターフェイスと変数として定義されており、これを TypeScript の extends で継承することはできません。

ただ、根本的なことを言えば JavaScript にクラスはないので、JavaScript のオブジェクトである Error を『継承』をするのはそもそもナンセンスだという考え方もあります。プロトタイプはプロトタイプであって、継承ではないのです。Error はいかにもクラスのように見えますが、これは単なるオブジェクトに過ぎません。クラスは TypeScript で初めて持ち込まれるものなので、TypeScript でクラスとして定義されたもの以外を継承しようというのは意味がないかもしれません。

どうしても『継承』したければ、(1) JavaScript で通常行うような prototype を設定することで継承もどきをする(Stack Overflow での結論もそうなっているみたい) か、(2) 自分で Error を implements したの基底クラスを作れば？(Stack Overflow での回答) という方法もありますし、(3) lib.d.ts を改ざんするという手もあります。独自の基底クラスを作る方法は、たぶんこの質問者が望んでいることではないでしょう。筆者としては Error がクラスになっているほうがスマートだとは思いますが、lib.d.ts はそうなっていません。これにはもしかしたら Error をパーシャルにしておきたいという理由もあるのかもしれません。それに、型を interface にしておいたほうがいろいろ柔軟に扱えます。

以下は、上記のページから引用した質問者による JavaScript と同じ方法で「継承」を行うというオーソドックスな結論ですが、確かにこれで十分だと思います。

```js
function UploadError (message: string, code: number) {
    this.message = message;
    this.code = code;
}

UploadError.prototype = new Error();

UploadError.prototype.constructor = UploadError;

UploadError.prototype.getCode = (): number => {
    return this.code;
}
```

**あくまで TypeScript は JavaScript をちょっとマシに書くだけのシステムです。JavaScript で出来ていたことが TypeScript でやりにくいなと思ったら、JavaScript と同じ方法でやればいいのです。**型チェックが邪魔だと思ったら、とりあえず `&lt;any&gt;` つけとけば全部回避できます。TypeScript が JavaScript で培ったノウハウの使用を妨げることはほとんどありません。 

### enchant.js の動的なクラスの扱い

[こちらのブログ](http://d.hatena.ne.jp/derui/comment?date=20130210&amp;section=1360478426)では、enchant.js で動的に定義されるクラスを TypeScript ではどのように扱えばよいかということについて検討されています。そこで提案されている方法なのですが、どうもかなり遠回りの解決策になっているように思いますので、本来の解決策と思われるものを説明しておきます。[こちら](http://naosim.blog16.fc2.com/blog-entry-384.html)でも enchant.js のクラスを継承しようとしてうまくいかなかったようです。TypeScript のコンセプトをよく理解しておかないと、このあたりは相当に迷いやすいと思われます。 この節では　enchant.js を例としてこの問題を解説していますが、ほかのフレームワークでも同じことが言えます。

#### enchant.js の『クラス』に対して TypeScript の継承はできない

enchant.js のようなフレームワークでは、独自に『クラス』を定義する機構が用意されていることがあります。enchant.js の場合は、enchant.Class.create という関数を呼ぶことで『クラス』を定義することができるようになっています。まず気をつけなくてはならないのは、**基本的に各フレームワークで独自に用いられている『クラス』を TypeScript の extends で継承することはできない**、ということです。TypeScript のクラスを各フレームワークの継承の機構で拡張することもできません。TypeScript の extends で継承できるのは、基本的には　TypeScript で定義されたクラスのみです。運よく正常に継承できてしまう場合もありますが、『TypeScript の継承と互換性がある』とはっきり明示されているのでなければ、今はたまたま正常に動いているように見えても将来の仕様変更により失敗するようになるかもしれません。

JavaScript には本来クラスは存在せず、各フレームワークで独自に導入された『クラス』それぞれの互換性には保証はまったくありません。JavaScript で『継承』っぽいものを実現する手段には[いろいろ](http://d.hatena.ne.jp/shogo4405/20070121/1169394889)あり、本稿の冒頭で紹介した通り各フレームワークの『クラス』の実態はバラバラです。各フレームワークの『クラス』が異なるものである以上、これらを混ぜて使用するようなことは原則的にできません。各フレームワーク用意された『クラス』を継承するには、そのフレームワークで用意された方法で継承するしかないのです。（そのような混乱を避けるために統一されたクラスの機構を用意するというのも、TypeScript の意義のひとつです。）

筆者の書いている three.js のアンビエント宣言 three.d.ts には、JavaScript で表現された『クラス』をそのまま TypeScript のクラスとしてアンビエント宣言を書いている箇所が多くあります。これは原則的には安全な定義とはいえず、これらのアンビエント宣言のクラスを継承して新たなクラスを定義しようとすると予期せぬトラブルを招く可能性があります。ただ、これをインターフェイスとコンストラクタの組み合わせで表現しようとすると、これが『クラス』とは認識しづらくなり、また型階層を自動的に認識するようなことが難しくなります。また、three.js の設計上 three.js のクラスの継承が必要になることはまずないため、安全でないことを知りつつあえてわかりやすさを優先した定義になっています。

#### JavaScript に始まる

あちらのブログの例では、TypeScript で動的にプロパティに追加をするようなことを実現するために、JavaScript のときには存在しなかった関数 Hoge.create が新たに定義され、_singleton という静的なプロパティも追加されています。しかしながら、TypeScript で JavaScript と同じことを実現しようとするとき、追加の処理が必要になることはまずありません。なぜなら、TypeScript は JavaScript のスーパーセットであり、JavaScript とまったく同じことができるからです。

今回やりたいことを、まず JavaScript で考えてみましょう。enchant.Sprite を継承し、新たなプロパティ color が追加されたクラス Hoge を定義したいとします。これを JavaScript で実現すると次のようなコードになると思います(わかりやすくするため、あちらのブログの例より単純化しています)。

```js
var Hoge = enchant.Class.create(enchant.Sprite, {
    initialize : function (width, height) {        // enchant.js のコンストラクタ的なモノ
        enchant.Sprite.call(this, width, height);  // スーパークラスのコンストラクタ的なモノ
        this.color = "#000000";                    // Hoge に追加されるプロパティ
    }
});

var hoge = new Hoge();       // Hoge をインスタンス化
console.log(hoge.color);     // Sprite にはない新たなプロパティ color にアクセスできる
```

この JavaScript ソースコードには Hoge.create や _singleton は存在しませんが、同じものを TypeScript で実現するときもこれらは不要です。次はこの JavaScript ソースコードをどうやって TypeScript に移植するか、ということを検討していきます。

#### 何が問題か

まず、上記のコードをそのままコピーして Playground に突っ込んでみると案の定コンパイルエラーになりますが、まず出てくるエラーは　"The name 'enchant' does not exist in the current scope" すなわち enchant や Sprite というオブジェクトが見つからない、というものです。従って、これらのオブジェクトのアンビエント宣言を行わなければなりません。TypeScript では enchant はモジュール、Class はオブジェクト、create は Class のプロパティの関数だと考えるのが自然でしょう。最低限のアンビエント宣言の例は次のようなものになります。
```js
declare module enchant {
    var Class: {
        create(superClass: Function, definition: any): new(...args: any[])=>Object;
    };

    interface ISprite {}
    var Sprite: new(width: number, height: number)=>ISprite;
}
```

ここで、
```js
new(...args: any[])=>Object 
```

という型リテラルは、このような型をもつオブジェクトがコンストラクタであることを示す『コンストラクタ型リテラル』です。このような型をもつオブジェクトは new でインスタンス化できるので、new Hoge() というコードがコンパイルできるようになります。さて、このアンビエント宣言を先ほどのコードの先頭に追加してみましょう。すると、先ほど出ていたエラーが解決するものの、その代わりに

```js
console.log(hoge.color);
```

の行で "The property 'color' does not exist on value of type 'Object'" つまり hoge には color というプロパティが見つからない、というエラーが出るようになります。これは、create の返り値が 

```js
new(...args: any[])=>Object;
```

という型であり、hoge の型が Object となっているからです。しかし、実際には enchant.Class.create の機構によって new Hoge() で作成されたオブジェクトが color というプロパティを持っているのは間違いありません。これが、TypeScript で動的に定義されたプロパティにアクセスできない、という問題です。では、create の返り値を color というプロパティを持っているようなオブジェクトとなるようにアンビエント宣言を変えればよいのでしょうか？create は Hoge 以外のクラスを定義するのにもつかわれますから、返り値を 

```js
create(superClass: Function, definition: any): new()=>Hoge;
```

というように特定の型に制限するわけにはいきません。そのようにすると例えば Sprite を拡張する別のクラス Piyo を　create で定義することができなくなってしまうからです。それに create で作られるクラスがどんな型を持つかは事前にはわからないので、Object にするしかないのです。create が Hoge に依存しているというのも明らかにおかしいです。

また、create で作られた『クラス』から新たなオブジェクトを作り出す時のコンストラクタの引数は ...args: any[] というどんな引数でも渡せる定義になっていますが、create がどのようなクラスに対して使われるのかわからないため、このようにどんなものでも渡せるように定義せざるをえません。これでは、Hoge のコンストラクタにどんな引数でも渡せることになるので、引数の個数や型をミスする可能性が生じるという問題も起こっています。

```js
new Hoge("100", "200");      // 引数の型がおかしいのに、コンパイルエラーにならない
```

#### コンパイラに型を教える

これらの問題を解決するには、create や new Hoge() で作られたオブジェクトがどんな型を持っているかをうまく表現する必要があります。new Hoge() で作られるオブジェクトは Sprite のプロパティに新たなプロパティ　color を付け加えたものです。これは新たな型ですから、次のようなインターフェイスであらわすことができます。

```js
interface IHoge extends enchant.ISprite{
    color: string;
}
```

IHoge は enchant.ISprite のすべてのプロパティを継承しており、なおかつ color というプロパティも持っているというわけです。そして、enchant.Class.create で作られる『クラス』は、この IHoge であるようなオブジェクトを new で作ることができるコンストラクタです。enchant.js で定義される『クラス』であっても、その型を TypeScript のインターフェイスで示すことはもちろん構わないわけです。しかし、enchant.Class.create の型は 

```js
new(...args: any[])=>Object; 
```

で、ただの Object を作るコンストラクタになっています。**Hoge を定義するこの　enchant.Class.create　の呼び出しで作成されるコンストラクタの型は new(width: number, height: number)=>IHoge　であるはずですが、TypeScript コンパイラはもちろんそんなことは知らないので　new(...args: any[])=>Object　という型だとみなしています。**ここで型の特殊化が不足しており、これが color のプロパティにアクセスできない原因となっています。従って、次のようにキャストで TypeScript コンパイラに教えてしまえばいいのです。

```js
var Hoge = &lt;new(width: number, height: number)=>IHoge&gt; enchant.Class.create(enchant.Sprite, {
    initialize : function (width: number, height: number): void {
        enchant.Sprite.call(this, width, height);
        this.color = "#000000"; 
    }
});
```

1行目で new(...args:[])=>Object を　new()=>IHoge　にキャストしています。これで Hoge の型は new()=>IHoge になるので、new Hoge() が返すのは IHoge になります。この IHoge には color が定義されているので、これで無事に enchant.Class.create で定義されたクラスのプロパティ color にアクセスできるようになりました。完全なコードは次のようになります。読みやすいように、必ずしも必要でない型注釈についても記述してあります。

```js
// enchant.js のアンビエント宣言
declare module enchant {
    var Class: {
        create(superClass: Function, definition: any): new(...args: any[])=>Object;
    };

    interface ISprite {}
    var Sprite: new(width: number, height: number)=>ISprite;
}

// 新たな型 IHoge をインターフェイスで定義する
interface IHoge extends enchant.ISprite{
    color: string;
}

// Hoge を参照するための変数を宣言する
var Hoge: new(width: number, height: number)=>IHoge;

// 『クラス』を enchant.js の create で実際に作成する
Hoge = &lt;new(width: number, height: number)=&gt;IHoge&gt; enchant.Class.create(enchant.Sprite, {
    initialize : function (width: number, height: number): void {
        enchant.Sprite.call(this, width, height);
        this.color = "#000000"; 
    }
});

// Hoge を使ってみる
var hoge: IHoge = new Hoge(100, 200);
console.log(hoge.color);
```

これをコンパイルすると、型注釈がきれいに取り除かれて、本来の JavaScript だけが残ります。これは JavaScript で直接書いた場合とほぼ同一です。
TypeScript では JavaScript と同じことを型安全に行えるということがわかります。

```js
var Hoge;
Hoge = enchant.Class.create(enchant.Sprite, {
    initialize: function (width, height) {
        enchant.Sprite.call(this, width, height);
        this.color = "#000000";
    }
});
var hoge = new Hoge(100, 200);
console.log(hoge.color);
```

TypeScript は JavaScript でやっていたことを安全にできるようにするものなので enchant.js の『クラス』の扱いは　TypeScript でも JavaScript とまったく同じですが、
enchant.js の『クラス』や『継承』を TypeScript コンパイラは認識できないので TypeScript コンパイラの型チェックを納得させるためには適切な型注釈が必要になる、ということです。

#### まとめ

jsdo.it にも[enchant.js でクラスの継承を行うサンプル](http://jsdo.it/Kon/hyaha)を用意しておいたので、参考までにどうぞ。

* フレームワーク独自の『クラス』は TypeScript のクラスとは異なるので、TypeScript の extends で継承することはできない。各フレームワークに組み込みの『クラス』はそのフレームワーク自身に用意された機構でクラスの継承を行い、TypeScript のクラスは TypeScript のクラス定義で継承を行う。
* フレームワーク独自の『クラス』や『継承』については TypeScript は何も知らないので、インターフェイスとキャストで型を教えればよい。
* めんどくさいなら `&lt;any&gt;`

### Date の演算

TypeScript の Issue Trackerに[Date どうしの引き算ができないんだけど](http://typescript.codeplex.com/workitem/156)というものがあります。

```js
var millis = new Date() - new Date(1970, 0, 1); // Operator '-' cannot be applied to types 'Date' and 'Date'
```

JavaScript に精通したひとなら当然コンパイルが成功すべきコードに思えるのでしょうが、静的型付けにどっぷりな筆者としてはコンパイルエラーで異議なしです。
筆者としては素直に

```js
var millis = new Date().getTime() - new Date(1970, 0, 1).getTime();
```

って書けばいいのでは？と思いますが、これが煩わしいと思う人も結構いるのかもしれません。JavaScript で Date が減算できるのは、別に `-` がオーバーロードされてるだとかいうことではありません。[EcmaScript 262](http://www.ecma-international.org/ecma-262/5.1/Ecma-262.pdf)を調べてみると、

>15.9.6 Properties of Date Instances
>
>Date instances inherit properties from the Date prototype object and their [[Class]] internal property value is "Date". Date instances also have a [[PrimitiveValue]] internal property. The [[PrimitiveValue]] internal property is time value represented by this Date object.

とのこと。 `-` 演算子を適用すると、ToPrimitive と呼ばれている操作と ToNumber と呼ばれる操作を適用して number に自動的に変換されるのですが、このときに ToPrimitive はオブジェクトの [[PrimitiveValue]] を参照します。Date の場合は "time value" すなわち getTime() や valueOf() で得られる数と同じものが [[PrimitiveValue]] なので、さきほどのコードは JavaScript では geTime() したのと同じ振る舞いになるわけです。つまり、これは JavaScript が型を自動的に変換するのが原因なのですが、
型に厳格な TypeScript がそうホイホイと型を変換したりするはずがありません。そこで、次のような回避策が紹介されています。

```js
var millis = Date.now() - +(new Date(1970, 0, 1));
```

演算子が並んでいてちょっと奇妙ですが、TypeScript では単項の + や - をつけた場合はちゃんと number に変換できます(4.14.2 The +, –, and ~ operators)。なるほどそういう回避策もありますが、前の Error の継承のところで説明した通り、`&lt;any&gt;` をつければ型の不一致はすべて解決します。なので、こういう手もあります。

```js
var millis = &lt;any&gt;Date.now() - new Date(1970, 0, 1);
```

さきほどの単項 +/- をつける方法だとコンパイル後の JavaScript に余計な + が残ってしまいますが、`&lt;any&gt;` をつけるとそれがないのですっきりするし、何より `&lt;any&gt;` は万能なのであれこれ回避策で頭を巡らせる必要がありません。TypeScript で JavaScript と同じことをしようとして型エラーが出たら、とりあえず `&lt;any&gt;` をつける。これでだいたい解決するので覚えておきましょう。

### クラスやインターフェイスの別名

現状の TypeScript の言語仕様の大きな問題として、型の別名が定義できないというものがあります。この節を読んで時間を浪費してしまわないように結論から申し上げてしまうと、**TypeScript でモジュール以外の別名を定義するのは困難**だと思っていたほうがいいでしょう。安易に別名をつけようと工夫するといろいろ問題を引き起こします。それがなぜかということを知りたいかたは、このままこの節を読み進めていただければと思います。

Java なら `import PackageName.*;` でパッケージのクラスとインターフェイスを単純名で全部インポートできますし、`import PackageName.AnyClass;` で特定のクラスのみをインポートできるので、パッケージの名前が長くても問題ありません。C# なら更に柔軟に `using AnyAlias = NameSpaceName.AnyClass` のように別名をつけることさえできます。TypeScript ではどうするのがいいのでしょうか。クラスの別名は非常に厄介ですが、インターフェイスの別名やオブジェクトの別名**っぽい**ことはそれほど難しくはありません。インターフェイスの別名には、単に元のインターフェイスを継承するような空のインターフェイスを定義する手があります。Structual Subtyping のお陰でどっちがどっちを extends しているということは関係ないので、本名と別名のあいだで自由にオブジェクトをやり取りできます。

```js
interface Graphics2D extends CanvasRenderingContext2D {}

var g:Graphics2D;
var h:CanvasRenderingContext2D;

g = h;  // どっちにどっちを代入しても大丈夫
h = g;
```

オブジェクトの別名も、もちろん単にそういう別名の変数を定義して代入すればいいですね。

```js
var XHR = XMLHttpRequest;
```

しかし、クラスの場合はインターフェイスのようにはいきません。もとのクラスを継承するような空のクラスを作ったとしても、
別名のクラスのオブジェクトをもとのクラスの変数に代入できないので、これはとても別名とは言えません。

```js
class Vector3 extends THREE.Vector3 { }

var v: THREE.Vector3;
var u: Vector3;

v = u;
u = v; // Cannnot convert'THREE.Vector3' to 'Vector3'
```

もちろん `&lt;any&gt;` を乱用すれば代入できますが、そういう問題でもありません。
なにか良い方法はないものだろうかと筆者は次のような方法を検討しました。
次のような長い名前のモジュールにクラスがあったとしましょう。

```js
module Long.Long.Annoying.Namespace {
    export class Vector2 {
        x: number;
        y: number;
        constructor(x: number, y: number);
    }
}
```

このクラスを本名で使うのはすごく面倒ですね。

```js
var v: Long.Long.Annoying.Namespace.Vector2 = new Long.Long.Annoying.Namespace.Vector2(10, 20);
```

クラスの別名を定義できるようにするために、このクラスを次のように interface と var を使って書き換えます。このように interface と var で定義しても、class とほぼ同じように型注釈やコンストラクタ呼び出しができます。このような擬似的なクラスの定義は、lib.d.ts で使われているのと同じ方法です。

```js
module Long.Long.Annoying.Namespace {
    export interface IVector2 {
        x: number;
        y: number;
    }
    export var Vector2: {
        new (x: number, y: number) : IVector2;
    };
}

// 普通に new や型注釈できる
var v:new Long.Long.Annoying.Namespace.IVector2 = new Long.Long.Annoying.Namespace.Vector2(10, 20);
```

lib.d.ts で String というインターフェイスと String という変数が共存しているように、グローバルな名前空間では型名と変数名を同じ名前に出来るのですが、モジュール内の型と変数では同名での定義は可能なものの、外部からは変数が型名を隠してしまって、型注釈でうまく型名の方を参照できないようです。このため、インターフェイスと変数が異なる名前になっています。

この形式であれば、型はインターフェイスでコンストラクタはただの変数なので、それぞれ別名を定義することができます。

```js
// 型の別名の定義
interface IVector2 extends Long.Long.Annoying.Namespace.IVector2 {}

// コンストラクタの別名の定義
var Vector2 = Long.Long.Annoying.Namespace.Vector2;
```

これで、次のように本名でも別名でも型注釈をつけたりコンストラクタを呼んだりすることができます。

```js
// 本名での型注釈とコンストラクタ呼び出し
var v: Long.Long.Annoying.Namespace.IVector2 = new Long.Long.Annoying.Namespace.Vector2(10, 20);

// 別名での型注釈とコンストラクタ呼び出し。おお！短い！
var u: IVector2 = new Vector2(10, 20);
```

さて、問題は本名の型と別名の型の変数に互換性があるのか？ということですが、これらの型はインターフェイスなので次のようにお互いにお互いを代入してもエラーは出ません。やったね！

```js
// 本名の変数と別名の変数に互換性はあるのか？
v = u;  // Long.Long.Annoying.Namespace.IVector2 に IVector2 を代入できる！
u = v;  // IVector2 に Long.Long.Annoying.Namespace.IVector2 を代入できる！
```

……。さて、クラスやインターフェイス、変数の別名について検討してきましたが、よく訓練されたプログラマならすごく**コレジャナイ感**を感じていただけるのではないでしょうか。たしかに別名を定義できたものの、いろいろ問題は山積していますね。

#### クラスがどうみてもクラスに見えない
interface と var を使ってクラスっぽいものを作ることは lib.d.ts でも多用されていますが、この定義は一見してクラスのようには見えません。せっかく TypeScript にクラスがあるのに、この機構を使えないのはいろいろ損失が大きいです。

#### 型名とコンストラクタ名が違う
クラスベースオブジェクト指向言語ではたいてい new クラス名() でインスタンス化できることが多いので、クラス名とコンストラクタ名が異なるのは結構違和感があると思います。

#### クラスの別名を定義するのに型名とコンストラクタ名を別々に行わなければならない
別名を定義するのにいちいち２行かかります。確か面倒を避けるために別名を定義しようとしたのに……。

#### モジュールのメンバをまとめてインポートできない
結局 Java の import Hoge.*; のようなことはできません。ダメじゃん。

#### 他のソースファイルにも影響がでる
本当にそういう名前の型が定義されてしまうので、他のソースファイルからでもその別名を参照可能です。別々のソースファイルでそれぞれ別名を定義すると、名前の衝突が起こります。別名を付けたければスコープを作っておかないと危険ですが、この辺りは JavaScript でも同じことです。


というわけで、現時点では TypeScript でモジュール以外の別名を定義しようと姑息な工夫をするのは控えたほうがいいと思います。安易に別名をつけるといろいろ問題を引き起こします。もしかしたら今後別名が付けられるように言語仕様が変更される可能性もあるでしょうから、そうなるように祈りましょう……。




### 落穂拾い

知らなくてもたぶん全然困らない豆知識的なものも、一応メモしておこうと思います。暇で仕方のないひとだけ読んでください。

#### 関数なモジュール

JavaScript の関数はただのオブジェクトなのでプロパティを持つことができ、モジュールとして使われているオブジェクトが関数としても呼び出せるというような API をもつライブラリがいくつか存在します。TypeScript 0.8 以前では、このような API を表現するためにモジュールの定義に無名の関数を定義するような妙な仕様が検討されていましたが、TypeScript 0.9 以降は識別子の扱いが整理され、関数として呼び出せるモジュールのような定義もごく自然に定義できるようになりました。TypeScript で関数にプロパティを追加してモジュールのように扱うには、まずその関数を定義したあとに、同名でモジュールの定義を行います。次のサンプルでは、`readInput` という関数と同名で `readInput` というモジュールを定義しています。

```js
function readInput(separator = readInput.defaultSeparator) {
    // read input
}

module readInput {
    export var defaultSeparator = ":";
}
```
こうすると、上記のコードでやっているように `readInput.defaultSeparator` というようにモジュールのメンバにアクセスできますし、同じオブジェクトを `readInput()` で関数として呼び出すこともできます。

ちなみに、先にモジュールを定義してから同名の関数を定義することはできません。TypeScript のモジュールの構文は、その名前のオブジェクトが存在すればそのオブジェクトにそのモジュールのメンバが追加するように定義するものですが、存在していなければ新たにモジュールとなるオブジェクトを定義します。先にモジュールが定義されてしまうと、モジュールのオブジェクトと関数のオブジェクトがマージされないので識別子の
が衝突し、コンパイルエラーになります。

* 参考: [Announcing TypeScript 0.9](http://blogs.msdn.com/b/typescript/archive/2013/06/18/announcing-typescript-0-9.aspx)

#### 引数の数と互換性

関数の型は、より引数の数の多い関数の型へ暗黙に変換することができます。コールバックですべての引数が必要ないときなどでちょっと便利です。確かにすべての引数を受け取らなくても型の安全性という面では問題ありませんね。

```js
var f:(a:number, b:number)=>number;

var g:(a:number)=>number;

f = g;  // OK!

g = f;  // 逆方向の代入はコンパイルエラー
```

#### コンストラクタ型リテラル

関数の型を表す型リテラルがあるように、コンストラクタの型を表す**コンストラクタ型リテラル**というものもあります (3.5.6 Constructor Type Literals)。オブジェクト型リテラルさえあればじゅうぶんなので、あんまり欲しくなる場面は多いとは思いませんが……？

```js
interface Hoge{
}
var Hoge: new()=>Hoge;    // var Hoge: {new():Hoge;}; と同じ意味だけど 2 文字短い！やったね！

var hoge:Hoge = new Hoge(); // OK!　わりとどうでもいい
```

## おわりに

現在検討されている将来の仕様については、[Design notes](http://typescript.codeplex.com/wikipage?title=Design%20Notes%3a%20Generics)を見てみると何となく動向がつかめるかもしれません。

筆者はすでに TypeScript でいくつかのプロジェクトを始めています。たとえば、動的な言語である JavaScript では本質的に難しいドキュメントジェネレータを TypeScript の環境定義ファイルを使用して出力するようなことを試しています。もし興味があるようならそちらもご覧ください。

* [dtsdoc](https://github.com/kontan/dtsdoc) - *.d.ts を利用したドキュメンテーションジェネレータ。TypeScript の型システムは JavaScript そのままなので、これで出力されたドキュメントは javaScript のユーザにとってもそのまま使えます。
* [Parsect](https://github.com/kontan/parsect) - TypeScript でパーサを書くためのライブラリ。文字列のパーシングはプログラミングにおける永久の課題でもありますが、Haskell の Parsec に代表されるパーサコンビネータを TypeScript で作ってみました。可読性の高い記法で、LL(n) の文法のパーサを構築出来ます(たぶん)。上記の dtsdoc で使っています。
* [three.d.ts](https://github.com/kontan/three.d.ts) - HTML5/WebGL を利用した 3D グラフィックスライブラリ [three.js](http://mrdoob.github.com/three.js)の環境定義ファイル。複雑な three.js のようなライブラリでも型安全に使用することができます。

TypeScript の仕様は今後も変更されますので、動向にも注意しましょう。もし本稿に間違いがあるのを発見された場合は、よろしければ以下のメールアドレスもしくは Twitter までお知らせいただければ幸いです。本稿の著作権は筆者が保持するものですが、もちろん引用の権利を妨げるようなものではありませんので、法律の定めに従う限り引用は自由にしていただいて構いません。
引用を超える形態での利用についてはご相談ください。このページヘのリンクやツイートにも制限はありません。

## 変更履歴

* 2013/06/19 TypeScript 0.9 正式リリース祭り。列挙型と Overloading on COnstants, Declaration Merging, Export Assignments の説明を更新。まだ全体をちゃんと推敲していないので、0.8 以前の古い記述が残っています。そのうち全部見直します。気が向いたら。やばいマジで長くなってきた。でも今更ページ分けも面倒だし。このテキストは 0.8→0.9 のマイグレーションとしてまとめてはいないので、差分だけ知りたいかたは [Known breaking changes between 0.8 and 0.9](https://typescript.codeplex.com/wikipage?title=Known%20breaking%20changes%20between%200.8%20and%200.9) へどうぞ。
* 2013/05/23 0.9 の仕様へのリンクを貼っておく。すでに release-0.9.0 というブランチも切られているみたいだし、思ったより 0.9 のリリースは早そう。 
* 2013/05/04 ジェネリクス速報。コンパイラのバグ？いいから `&lt;any&gt;` だ！
* 2013/05/03 HTML ソースをのぞくとわかるけど、ページのほとんどが Markdown で書き直されてます。~~表示に不具合がある場合のために、しばらくは[旧版](/typescript_html/)も残しておきます。でも　Markdown で書いたりして検索エンジンさんが混乱したりしないだろうかという不安もあるのです。~~もし SEO に大きな悪影響か確認されたら、事前にコンパイルした HTML だけアップロードするようになるかもしれないけど、基本的には全部クライアントサイドでやるのがマイブーム。『型表明』→『型アサーション』と、あと 0.9 対応について少し加筆
* 2013/04/14 微調整。全体的にサンプルコードに統一感がないので、0.9 のリリースのときにまとめて整理しようと思う。いまどき生 HTML で書いてるというのもちょっと頭がどうかしていると思うので、GitHub Flavored Markdown みたいな記法でページ全体を書き直すという野望。
* 2013/03/17 enchant.js のクラスの扱いについて。このテキストは『クイックガイド』と名付けられているけど、『短くまとめられているので素早く読めるガイド』という意味ではなく『長いので急いで読まないと日が暮れちゃうガイド』という意味。
* 2013/03/08 0.8.3 での reference path まわりの変更について。いいから早くジェネリクスだ！はやくしろ！間に合わなくなっても知らんぞー！
* 2013/02/17 モジュール周りの説明を直したけど、まだ説明しきれていない気もする。
* 2013/02/16 ほかの JavaScript トランスコンパイル系言語の紹介をしようかと思ったけど、うまく比較して説明できなかったので結局削除。モジュール周りの説明が全然足りてないのでちゃんとしたい。
* 2013/02/09 上部の navbar からすぐに　Playground や言語仕様を開けます。Twitter のウィジェットも付いた。そしてやばいどんどん長くなってる
* 2013/02/08 省略可能なプロパティをすっかり忘れていた。ほかにあの言語仕様の説明抜けてるよっていうのがあったら教えてください。
* 2013/02/05 清々しいまでに bootstrap のサンプル丸パクりでページデザインの再構成。ts/js の見分けがつかなくなってユーザビリティ悪化してるので要調整。
* 2013/02/03 サンプルコードの調整と HTML の整理。サンプルコードについては良くないものが多いので、後で全面的に見直す必要がありそう
* 2013/01/29 そういや、型注釈って例のポシャった ES4 には入ってたけど、ES6 では入ってないんだよね？なんか ES についてすごい適当なこと書いてた気がする。正直もう ES には期待してないのですごくどうでもいいけど。 
* 2013/01/28 型の別名についての説明。蛇足な感じだけど、誰かが筆者のような無駄な努力を費やさないように願って。                
* 2013/01/25 インターフェイスの説明のサンプルの間違いを修正。ページのデザインに関しては全面的に再考する余地が大きい。硬派すぎる気がする 
* 2013/01/23 サンプルコードの枠線の色の説明を追加。今どき HTML を手書きって……。CMS 使えって話だよね。
* 2013/01/22 オーバーロードで本体の引数を any にしなければならないかのように書いていたけどそんなことはなかった。あと Number が他の型のサブタイプにならないって書いていたけど、明らかにおかしいので削除
* 2013/01/20 記述が増え過ぎて全然クイックじゃない件について。当初はもう少し淡白なページを考えていたんだけど、利点欠点を書き始めたあたりからどんどん記述が増えてきた
* 2013/01/19 お仲間の言語についての説明も追加。そろそろ長くなってきたので、ページ分けたほうがいいかな？めんどい
* 2013/01/18 空の列挙型についてのケーススタディを追加＆tscのバージョンアップにしたがってインデックスシグニチャの記述を修正＆教えてもらったタイプミスを修正。Thanks!
* 2013/01/16 クラス定義の解説で、なぜか多重継承ができるかのような書き方になっていたけど、もちろんそんなことはなかったぜ
* 2013/01/04 列挙型や可変長引数についての記述を追加
* 2012/11/?? 公開。詳しい日付忘れちゃった……
                    </pre>
                    
                    <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a>
                    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="http://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

                    <hr>
                    <div id='footer_container'></div>
                </div>
            </div>
        </div>

        <script src="../assets/bootstrap/js/bootstrap.js"></script>
        <script type="text/javascript" src="markblender.js"></script>
        <script type="text/javascript" src="indexer.js"></script>
        <script type="text/javascript"> $(prettyPrint); </script>
    </body>
</html>